<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto SuperTrend Monitor</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        [v-cloak] { display: none; }
        :root {
            --bg-color: #0b0f1e;
            --card-bg: rgba(22, 27, 34, 0.7);
            --card-border: rgba(48, 54, 61, 0.7);
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --accent-blue: #58a6ff;
            --accent-yellow: #d29922;
        }
        body { 
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Microsoft YaHei', sans-serif; 
            background: radial-gradient(1200px 500px at 10% 10%, #0b0f1e 0%, #0b0f1e 30%, #121329 60%, #131135 100%); 
            color: var(--text-primary); 
            min-height: 100vh; 
        }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #0d1117; }
        ::-webkit-scrollbar-thumb { background: #30363d; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #58a6ff; }
        
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        
        /* Modal Styles */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 1000; display: flex; justify-content: center; align-items: center; backdrop-filter: blur(8px); }
        .modal-content { background: #161b22; width: 95%; max-width: 1200px; height: 90vh; border-radius: 16px; border: 1px solid #30363d; display: flex; flex-direction: column; overflow: hidden; box-shadow: 0 20px 40px rgba(0,0,0,0.5); }
        .modal-header { padding: 20px 24px; border-bottom: 1px solid #30363d; display: flex; justify-content: space-between; align-items: center; background: #0d1117; }
        .modal-title { font-size: 1.25rem; font-weight: 700; color: #e6edf3; display: flex; align-items: center; gap: 12px; }
        .modal-close { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 50%; width: 32px; height: 32px; color: #8b949e; font-size: 1.5rem; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
        .modal-close:hover { background: rgba(248,81,73,0.2); color: #f85149; border-color: rgba(248,81,73,0.3); }
        .modal-body { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 20px; scroll-behavior: smooth; }
        
        .chart-container { background: #0d1117; border: 1px solid #30363d; border-radius: 12px; padding: 12px; display: flex; flex-direction: column; height: 420px; position: relative; box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
        .chart-header { display: flex; justify-content: space-between; margin-bottom: 12px; font-size: 0.9rem; font-weight: 600; color: #8b949e; padding: 0 10px; }
        .chart-wrapper { flex: 1; width: 100%; position: relative; }
        .loading-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(13,17,23,0.8); display: flex; justify-content: center; align-items: center; z-index: 10; color: #58a6ff; font-weight: 500; }
        
        .header { text-align: center; padding: 40px 20px 30px; margin-bottom: 20px; }
        .header h1 {
            font-size: 2.8rem;
            font-weight: 800;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, #6366f1, #a855f7, #0ea5e9);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 12px;
            text-shadow: 0 10px 30px rgba(99, 102, 241, 0.2);
        }
        .header p { color: #8b949e; font-size: 1.1rem; }
        
        .api-badge { background: linear-gradient(90deg, #238636, #2ea043); color: white; padding: 4px 10px; border-radius: 99px; font-size: 0.75rem; font-weight: 700; letter-spacing: 0.5px; box-shadow: 0 2px 5px rgba(35, 134, 54, 0.3); }
        
        .status-bar { 
            display: flex; justify-content: space-between; align-items: center; padding: 16px 24px; 
            background: var(--card-bg); border: 1px solid var(--card-border); 
            border-radius: 16px; margin-bottom: 24px; backdrop-filter: blur(10px); 
            box-shadow: 0 8px 24px rgba(0,0,0,0.2); flex-wrap: wrap; gap: 16px; 
        }
        .status-left { display: flex; align-items: center; gap: 24px; flex-wrap: wrap; color: #8b949e; font-size: 0.9rem; font-weight: 500; }
        .status-item { display: flex; align-items: center; gap: 8px; }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; background: #3fb950; box-shadow: 0 0 10px rgba(63, 185, 80, 0.5); animation: pulse 2s infinite; }
        .status-dot.loading { background: #d29922; box-shadow: 0 0 10px rgba(210, 153, 34, 0.5); }
        .status-dot.error { background: #f85149; box-shadow: 0 0 10px rgba(248, 81, 73, 0.5); animation: none; }
        @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(1.1); } }
        
        .controls { display: flex; gap: 12px; margin-bottom: 24px; flex-wrap: wrap; justify-content: center; }
        .btn { 
            padding: 10px 20px; border: 1px solid #30363d; border-radius: 12px; 
            background: rgba(22, 27, 34, 0.8); color: #c9d1d9; cursor: pointer; 
            font-size: 0.9rem; font-weight: 600; font-family: 'Inter', sans-serif;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); 
        }
        .btn:hover:not(:disabled) { background: #30363d; transform: translateY(-1px); color: #fff; border-color: #8b949e; }
        .btn:active:not(:disabled) { transform: translateY(0); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .btn.active { background: rgba(88, 166, 255, 0.15); border-color: #58a6ff; color: #58a6ff; }
        
        .progress-bar { width: 100%; height: 3px; background: rgba(48, 54, 61, 0.3); border-radius: 2px; overflow: hidden; margin-top: -12px; margin-bottom: 20px; opacity: 0.8; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #238636, #3fb950, #238636); background-size: 200% 100%; animation: shimmer 2s infinite linear; transition: width 0.3s ease; width: 0%; }
        @keyframes shimmer { 0% { background-position: 100% 0; } 100% { background-position: -100% 0; } }
        
        .stats-row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 24px; }
        .stat-card { 
            background: var(--card-bg); border: 1px solid var(--card-border); 
            border-radius: 16px; padding: 20px; text-align: center; 
            backdrop-filter: blur(10px); transition: transform 0.2s, border-color 0.2s; 
        }
        .stat-card:hover { transform: translateY(-3px); border-color: #58a6ff; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        .stat-card .label { color: #8b949e; font-size: 0.8rem; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
        .stat-card .value { font-size: 1.8rem; font-weight: 800; line-height: 1.2; }
        .stat-card .value.green { color: #3fb950; text-shadow: 0 0 20px rgba(63, 185, 80, 0.2); } 
        .stat-card .value.red { color: #f85149; text-shadow: 0 0 20px rgba(248, 81, 73, 0.2); } 
        .stat-card .value.yellow { color: #d29922; text-shadow: 0 0 20px rgba(210, 153, 34, 0.2); } 
        .stat-card .value.blue { color: #58a6ff; text-shadow: 0 0 20px rgba(88, 166, 255, 0.2); }
        
        .table-container { 
            background: var(--card-bg); border: 1px solid var(--card-border); 
            border-radius: 16px; overflow-x: auto; backdrop-filter: blur(10px); 
            box-shadow: 0 10px 30px rgba(0,0,0,0.1); 
        }
        table { width: 100%; border-collapse: separate; border-spacing: 0; min-width: 900px; }
        th { 
            background: rgba(13, 17, 23, 0.95); padding: 16px 20px; text-align: left; 
            font-weight: 600; color: #8b949e; font-size: 0.8rem; 
            text-transform: uppercase; letter-spacing: 0.5px;
            border-bottom: 1px solid #30363d; white-space: nowrap; 
            position: sticky; top: 0; z-index: 10; backdrop-filter: blur(5px);
        }
        td { padding: 14px 20px; border-bottom: 1px solid rgba(48, 54, 61, 0.4); vertical-align: middle; transition: background 0.1s; }
        tr:last-child td { border-bottom: none; }
        tr:hover td { background: rgba(56, 139, 253, 0.05); }
        
        .text-center { text-align: center; }
        .text-right { text-align: right; }
        
        td.text-center .trend-badge { margin: 0 auto; }
        td.text-center .mini-chart { margin: 0 auto; }
        
        .coin-info { display: flex; align-items: center; gap: 12px; }
        .coin-icon { width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: #1b2230; overflow: hidden; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .coin-icon img { width: 70%; height: 70%; object-fit: contain; display: block; }
        .coin-icon-fallback { width: 100%; height: 100%; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; font-weight: 700; color: #ffffff; background: linear-gradient(135deg, #30363d, #161b22); }
        .coin-name { font-weight: 600; color: #e6edf3; font-size: 0.95rem; font-family: 'Inter', 'Microsoft YaHei', sans-serif; }
        .coin-symbol { color: #8b949e; font-size: 0.8rem; font-weight: 500; }
        .price { font-weight: 600; color: #e6edf3; font-size: 0.95rem; font-variant-numeric: tabular-nums; letter-spacing: 0.5px; }
        
        .btn-star {
            background: transparent;
            border: none;
            cursor: pointer;
            color: #484f58;
            font-size: 1.4rem;
            transition: all 0.2s;
            padding: 0;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .btn-star:hover {
            color: #e6edf3;
            transform: scale(1.2);
        }
        .btn-star.active {
            color: #d29922; /* Gold color */
            text-shadow: 0 0 15px rgba(210, 153, 34, 0.6);
            animation: star-pulse 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes star-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.4); }
            100% { transform: scale(1); }
        }

        .trend-badge { display: flex; flex-direction: column; align-items: center; min-width: 56px; border-radius: 8px; overflow: hidden; transition: transform 0.2s; }
        .trend-badge:hover { transform: scale(1.05); }
        .trend-badge .tf { font-size: 0.65rem; padding: 2px 0; background: rgba(0,0,0,0.2); color: rgba(255,255,255,0.7); width: 100%; text-align: center; font-weight: 600; }
        .trend-badge .signal { font-size: 0.75rem; font-weight: 700; padding: 4px 0; width: 100%; text-align: center; }
        .trend-badge.buy { background: linear-gradient(180deg, rgba(63, 185, 80, 0.1), rgba(63, 185, 80, 0.2)); border: 1px solid rgba(63, 185, 80, 0.3); }
        .trend-badge.buy .signal { color: #3fb950; text-shadow: 0 0 5px rgba(63, 185, 80, 0.3); }
        .trend-badge.sell { background: linear-gradient(180deg, rgba(248, 81, 73, 0.1), rgba(248, 81, 73, 0.2)); border: 1px solid rgba(248, 81, 73, 0.3); }
        .trend-badge.sell .signal { color: #f85149; text-shadow: 0 0 5px rgba(248, 81, 73, 0.3); }
        .trend-badge.neutral { background: rgba(210, 153, 34, 0.1); border: 1px solid rgba(210, 153, 34, 0.2); }
        .trend-badge.neutral .signal { color: #d29922; }
        .trend-badge.loading { background: rgba(88, 166, 255, 0.1); border: 1px solid rgba(88, 166, 255, 0.2); }
        .trend-badge.loading .signal { color: #58a6ff; animation: pulse 1.5s infinite; }
        
        .mini-chart { width: 90px; height: 36px; display: block; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2)); }
        
        .score-badge { display: inline-block; padding: 6px 12px; border-radius: 99px; font-size: 0.8rem; font-weight: 700; border: 1px solid transparent; letter-spacing: 0.5px; }
        .score-strong-buy { color: #3fb950; background: rgba(63,185,80,0.15); border-color: rgba(63,185,80,0.3); box-shadow: 0 0 10px rgba(63,185,80,0.1); }
        .score-buy { color: #2ea043; background: rgba(46,160,67,0.12); border-color: rgba(46,160,67,0.25); }
        .score-neutral { color: #d29922; background: rgba(210,153,34,0.12); border-color: rgba(210,153,34,0.25); }
        .score-sell { color: #f85149; background: rgba(248,81,73,0.12); border-color: rgba(248,81,73,0.25); }
        .score-strong-sell { color: #da3633; background: rgba(218,54,51,0.12); border-color: rgba(218,54,51,0.25); box-shadow: 0 0 10px rgba(218,54,51,0.1); }
        
        .insight-container { 
            display: grid; 
            grid-template-columns: repeat(4, 1fr);
            gap: 1px;
            background: var(--card-border); /* Acts as border for children */
            border: 1px solid var(--card-border);
            border-radius: 16px;
            overflow: hidden;
            margin-bottom: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        .insight-column { 
            background: var(--card-bg); 
            padding: 20px; 
            backdrop-filter: blur(10px); 
            display: flex; flex-direction: column;
            transition: background 0.2s;
        }
        .insight-column:hover { background: rgba(22, 27, 34, 0.9); }
        .insight-title { 
            font-size: 0.95rem; 
            font-weight: 600; 
            color: #e6edf3; 
            margin-bottom: 16px; 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: none;
            padding-bottom: 0;
            font-family: 'Inter', 'Microsoft YaHei', sans-serif;
        }
        .insight-title svg { width: 20px; height: 20px; color: #7d8590; }
        .insight-item { margin-bottom: 8px; font-size: 0.95rem; color: #8b949e; line-height: 1.6; font-family: 'Inter', 'Microsoft YaHei', sans-serif; }
        .insight-item:last-child { margin-bottom: 0; }
        
        .fng-value { font-size: 2.2rem; font-weight: 800; margin-left: 0; display: block; margin-top: 8px; line-height: 1.1; font-family: 'Inter', 'Microsoft YaHei', sans-serif; letter-spacing: -1px; }
        
        .sentiment-bar-bg {
            width: 100%; height: 6px; background: rgba(48, 54, 61, 0.5); border-radius: 3px; margin-top: 12px; overflow: hidden;
            display: flex;
        }
        .sentiment-bar-fill {
            height: 100%; border-radius: 3px; transition: width 1s ease-out;
        }
        
        .insight-section-header {
            font-size: 0.8rem; color: #7d8590; margin-bottom: 4px; font-weight: 500;
        }
        
        .insight-icon-box {
            width: 32px; height: 32px; border-radius: 8px; background: rgba(88, 166, 255, 0.1);
            display: flex; align-items: center; justify-content: center; color: #58a6ff;
            margin-bottom: 4px;
        }

        @media (max-width: 1100px) { 
            .insight-container { grid-template-columns: repeat(2, 1fr); gap: 1px; }
        }
        @media (max-width: 600px) { 
            .insight-container { grid-template-columns: 1fr; }
        }
        .fng-extreme-fear { color: #3fb950; } 
        .fng-fear { color: #a371f7; }
        .fng-neutral { color: #d29922; }
        .fng-greed { color: #f85149; }
        .fng-extreme-greed { color: #da3633; } 
        
        .chart-supertrend-legend {
            position: absolute; top: 12px; right: 70px; z-index: 20;
            font-size: 13px; font-weight: 600; padding: 8px 12px;
            border-radius: 8px; background: rgba(13, 17, 23, 0.9);
            border: 1px solid #30363d; backdrop-filter: blur(4px);
            pointer-events: none; display: flex; align-items: center; gap: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .st-legend-dot { width: 10px; height: 10px; border-radius: 50%; box-shadow: 0 0 8px currentColor; }
        
        /* Skeleton Loading Animation */
        .skeleton { background: linear-gradient(90deg, #161b22 25%, #21262d 50%, #161b22 75%); background-size: 200% 100%; animation: skeleton-loading 1.5s infinite; border-radius: 4px; color: transparent !important; }
        @keyframes skeleton-loading { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
        
        .spinner { width: 40px; height: 40px; border: 4px solid rgba(88, 166, 255, 0.1); border-radius: 50%; border-top-color: #58a6ff; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }

        @media (max-width: 900px) { .stats-row { grid-template-columns: repeat(2, 1fr); } .insight-container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div id="app" v-cloak class="container">
        <header class="header">
            <h1>üöÄ Crypto SuperTrend Dashboard</h1>
            <p>ÂÆûÊó∂ÁõëÊéßÂ∏ÇÂÄºÂâç100Âä†ÂØÜË¥ßÂ∏ÅÁöÑÂ§öÂë®ÊúüË∂ÖÁ∫ßË∂ãÂäøÊåáÊ†á <span class="api-badge">OKX API</span></p>
        </header>

        <div class="status-bar">
            <div class="status-left">
                <div class="status-item">
                    <span :class="['status-dot', loading ? 'loading' : '']"></span>
                    <span>{{ loading ? 'Ê≠£Âú®ËøûÊé•...' : 'Â∑≤ËøûÊé•' }}</span>
                </div>
                <div class="status-item">
                    <span>ÊúÄÂêéÊõ¥Êñ∞Ôºö</span>
                    <span>{{ lastUpdatedFormatted }}</span>
                </div>
            </div>
            <div>
                <button class="btn" @click="fetchData" :disabled="loading">{{ loading ? '‚è≥ Âä†ËΩΩ‰∏≠...' : 'üîÑ Âà∑Êñ∞Êï∞ÊçÆ' }}</button>
            </div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" :style="{ width: loadPercent + '%' }"></div>
        </div>

        <div v-if="sentiment" class="insight-container">
            <div class="insight-column">
                <div class="insight-title">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" /></svg>
                    Â∏ÇÂú∫ÊÉÖÁª™
                </div>
                <div class="insight-item" style="margin-top:auto;margin-bottom:auto;">
                    <div class="insight-section-header">‰ªäÊó•ÊÅêÊÖåË¥™Â©™ÊåáÊï∞</div>
                    <span :class="['fng-value', getSentimentClass(sentiment.today.value)]">
                        {{ sentiment.today.value }}
                        <span style="font-size:1.2rem;font-weight:600;color:#8b949e;vertical-align:middle;margin-left:4px;">{{ sentiment.today.value_classification }}</span>
                    </span>
                    
                    <div class="sentiment-bar-bg">
                         <div class="sentiment-bar-fill" :style="{width: sentiment.today.value + '%', backgroundColor: getSentimentColor(sentiment.today.value)}"></div>
                    </div>

                    <div style="font-size:0.85rem;color:#8b949e;margin-top:12px;display:flex;justify-content:space-between;">
                        <span>Êò®Êó•: <span style="color:#e6edf3;font-weight:600;">{{ sentiment.yesterday.value }}</span></span>
                        <span>
                             ÂèòÂåñ: <span :style="{color: (parseInt(sentiment.today.value) - parseInt(sentiment.yesterday.value)) >= 0 ? '#3fb950' : '#f85149', fontWeight: 600}">{{ parseInt(sentiment.today.value) - parseInt(sentiment.yesterday.value) > 0 ? '+' : ''}}{{ parseInt(sentiment.today.value) - parseInt(sentiment.yesterday.value) }}</span>
                        </span>
                    </div>
                </div>
            </div>

            <div class="insight-column">
                <div class="insight-title">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 013 19.875v-6.75zM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V8.625zM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V4.125z" /></svg>
                    Â∏ÇÂú∫Áä∂ÊÄÅ
                </div>
                <div class="insight-item" v-for="(line, idx) in sentiment.analysis" :key="'analysis-'+idx">
                    {{ line }}
                </div>
            </div>

            <div class="insight-column">
                <div class="insight-title">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3v11.25A2.25 2.25 0 006 16.5h2.25M3.75 3h-1.5m1.5 0h16.5m0 0h1.5m-1.5 0v11.25A2.25 2.25 0 0118 16.5h-2.25m-7.5 0h7.5m-7.5 0l-1 3m8.5-3l1 3m0 0l.5 1.5m-.5-1.5h-9.5m0 0l-.5 1.5m.75-9l3-3 2.148 2.148A12.061 12.061 0 0116.5 7.605" /></svg>
                    Ë°®Áé∞È¢ÑÊµã
                </div>
                <div class="insight-item" v-for="(line, idx) in sentiment.prediction" :key="'pred-'+idx">
                    {{ line }}
                </div>
            </div>

            <div class="insight-column">
                <div class="insight-title">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 001.5-.189m-1.5.189a6.01 6.01 0 01-1.5-.189m3.75 2.625v-8.196a2.25 2.25 0 011.053-1.948l.972-.584m-4.275 10.728a6.75 6.75 0 01-6.75 6.75v-1.5a5.25 5.25 0 005.25-5.25v-8.196a2.25 2.25 0 011.053-1.948l.972-.584m0 0a2.25 2.25 0 011.053 1.948v.984" /></svg>
                    Êìç‰ΩúÂª∫ËÆÆ
                </div>
                <div class="insight-item">
                    {{ sentiment.advice }}
                </div>
            </div>
        </div>

        <div class="controls">
            <input v-model="searchQuery" type="text" placeholder="ÊêúÁ¥¢Â∏ÅÁßç..." class="btn" style="min-width:260px;">
            <button class="btn" :class="{ active: viewMode === 'watchlist' }" @click="toggleViewMode">
                ‚≠ê Á≠õÈÄâÊ±† ({{ selectedCoins.size }})
            </button>
            <div style="width: 1px; height: 30px; background: #30363d; margin: 0 8px;"></div>
            <button class="btn" @click="sortBy('rank')">ÊåâÊéíÂêçÊéíÂ∫è {{ sortKey==='rank' ? (sortOrder==='asc'?'‚Üë':'‚Üì') : '' }}</button>
            <button class="btn" @click="sortBy('price')">Êåâ‰ª∑Ê†ºÊéíÂ∫è {{ sortKey==='price' ? (sortOrder==='asc'?'‚Üë':'‚Üì') : '' }}</button>
            <button class="btn" @click="sortBy('changePercent')">ÊåâÊ∂®Ë∑åÊéíÂ∫è {{ sortKey==='changePercent' ? (sortOrder==='asc'?'‚Üë':'‚Üì') : '' }}</button>
            <button class="btn" :class="{ active: filterStatus==='all' }" @click="setFilter('all')">ÂÖ®ÈÉ®</button>
            <button class="btn" :class="{ active: filterStatus==='bullish' }" @click="setFilter('bullish')">üü¢ ÁúãÊ∂®</button>
            <button class="btn" :class="{ active: filterStatus==='bearish' }" @click="setFilter('bearish')">üî¥ ÁúãË∑å</button>
            <button class="btn" :class="{ active: filterStatus==='neutral' }" @click="setFilter('neutral')">üü° ‰∏≠ÊÄß</button>
        </div>

        <div class="stats-row">
            <div class="stat-card"><div class="label">ÁúãÊ∂®‰ø°Âè∑</div><div class="value green">{{ stats.bullish }}</div></div>
            <div class="stat-card"><div class="label">ÁúãË∑å‰ø°Âè∑</div><div class="value red">{{ stats.bearish }}</div></div>
            <div class="stat-card"><div class="label">‰∏≠ÊÄß‰ø°Âè∑</div><div class="value yellow">{{ stats.neutral }}</div></div>
            <div class="stat-card"><div class="label">Â∑≤Âä†ËΩΩ</div><div class="value blue">{{ loadedCount }}/{{ coins.length }}</div></div>
        </div>

        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th class="text-center">#</th>
                        <th class="text-center" style="width: 50px;">ÈÄâ</th>
                        <th>Â∏ÅÁßç</th>
                        <th class="text-right">‰ª∑Ê†º</th>
                        <th class="text-right">‰ªäÊó•Ê∂®Ë∑å</th>
                        <th class="text-center">15ÂàÜÈíü</th>
                        <th class="text-center">1Â∞èÊó∂</th>
                        <th class="text-center">4Â∞èÊó∂</th>
                        <th class="text-center">Êó•Á∫ø</th>
                        <th class="text-center">Âë®Á∫ø</th>
                        <th class="text-center">ÁªºÂêàËØÑÂàÜ</th>
                        <th class="text-center">Ë∂ãÂäøÂõæ</th>
                    </tr>
                </thead>
                <tbody>
                    <tr v-if="loading && coins.length === 0" v-for="i in 10" :key="'skeleton-'+i">
                        <td class="text-center"><div class="skeleton" style="width: 20px; height: 16px; margin: 0 auto;"></div></td>
                        <td class="text-center"><div class="skeleton" style="width: 20px; height: 20px; margin: 0 auto; border-radius: 50%;"></div></td>
                        <td>
                            <div class="coin-info">
                                <div class="coin-icon skeleton"></div>
                                <div>
                                    <div class="skeleton" style="width: 60px; height: 14px; margin-bottom: 4px;"></div>
                                    <div class="skeleton" style="width: 40px; height: 12px;"></div>
                                </div>
                            </div>
                        </td>
                        <td class="text-right"><div class="skeleton" style="width: 80px; height: 20px; margin-left: auto;"></div></td>
                        <td class="text-right"><div class="skeleton" style="width: 60px; height: 20px; margin-left: auto;"></div></td>
                        <td class="text-center"><div class="trend-badge skeleton" style="border:none; height: 32px; margin: 0 auto;"></div></td>
                        <td class="text-center"><div class="trend-badge skeleton" style="border:none; height: 32px; margin: 0 auto;"></div></td>
                        <td class="text-center"><div class="trend-badge skeleton" style="border:none; height: 32px; margin: 0 auto;"></div></td>
                        <td class="text-center"><div class="trend-badge skeleton" style="border:none; height: 32px; margin: 0 auto;"></div></td>
                        <td class="text-center"><div class="trend-badge skeleton" style="border:none; height: 32px; margin: 0 auto;"></div></td>
                        <td class="text-center"><div class="score-badge skeleton" style="width: 60px; height: 24px; border:none; margin: 0 auto;"></div></td>
                        <td class="text-center"><div class="mini-chart skeleton" style="height: 36px; margin: 0 auto;"></div></td>
                    </tr>
                    <tr v-for="coin in filteredCoins" :key="coin.symbol" @click="openChart(coin)" style="cursor: pointer;">
                        <td class="text-center">{{ coin.rank }}</td>
                        <td class="text-center" @click.stop="toggleSelection(coin)">
                            <button class="btn-star" :class="{ active: isSelected(coin) }">
                                ‚òÖ
                            </button>
                        </td>
                        <td>
                            <div class="coin-info">
                                <div class="coin-icon">
                                    <img v-if="coin.image" :src="coin.image" :alt="coin.symbol" @error="coin.image = null">
                                    <div v-else class="coin-icon-fallback" :style="{ background: coinColor(coin.symbol) }">
                                        {{ coin.symbol.slice(0,3) }}
                                    </div>
                                </div>
                                <div>
                                    <div class="coin-name">{{ coin.name }}</div>
                                    <div class="coin-symbol">{{ coin.symbol }}/USDT</div>
                                </div>
                            </div>
                        </td>
                        <td class="text-right"><div class="price">${{ formatPrice(coin.price) }}</div></td>
                        <td class="text-right">
                            <span :style="{ color: coin.changePercent >= 0 ? '#3fb950' : '#f85149', fontWeight: 'bold' }">
                                {{ coin.changePercent >= 0 ? '+' : '' }}{{ coin.changePercent.toFixed(2) }}%
                            </span>
                        </td>
                        <td class="text-center"><trend-badge label="15m" :trend="coin.trend_15m"></trend-badge></td>
                        <td class="text-center"><trend-badge label="1h" :trend="coin.trend_1h"></trend-badge></td>
                        <td class="text-center"><trend-badge label="4h" :trend="coin.trend_4h"></trend-badge></td>
                        <td class="text-center"><trend-badge label="1d" :trend="coin.trend_1d"></trend-badge></td>
                        <td class="text-center"><trend-badge label="1w" :trend="coin.trend_1w"></trend-badge></td>
                        <td class="text-center score-cell"><span :class="['score-badge', scoreInfo(coin).klass]">{{ scoreInfo(coin).label }}</span></td>
                        <td class="text-center" v-html="generateMiniChart(coin)"></td>
                    </tr>
                    <tr v-if="filteredCoins.length === 0">
                        <td colspan="12" style="text-align:center;padding:40px;">
                            <div v-if="viewMode === 'watchlist'" style="display:flex;flex-direction:column;gap:10px;align-items:center;">
                                <span style="font-size:3rem;">‚≠ê</span>
                                <span style="font-size:1.2rem;font-weight:600;">Á≠õÈÄâÊ±†‰∏∫Á©∫</span>
                                <span style="color:#8b949e;">ËØ∑Âú®ÂàóË°®‰∏≠ÁÇπÂáªÊòüÂè∑ÂõæÊ†áÊ∑ªÂä†ÂÖ≥Ê≥®Â∏ÅÁßç</span>
                            </div>
                            <span v-else>ÊöÇÊó†Êï∞ÊçÆÊàñÊ≠£Âú®Âä†ËΩΩ‚Ä¶</span>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Chart Modal -->
        <div v-if="showModal" class="modal-overlay" @click.self="closeModal">
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">
                        <div class="coin-icon" style="width: 32px; height: 32px;">
                            <img v-if="activeCoin.image" :src="activeCoin.image" :alt="activeCoin.symbol">
                            <div v-else class="coin-icon-fallback" :style="{ background: coinColor(activeCoin.symbol) }">{{ activeCoin.symbol.slice(0,3) }}</div>
                        </div>
                        {{ activeCoin.symbol }} / USDT Â§öÂë®ÊúüË∂ÖÁ∫ßË∂ãÂäøÂõæË°®
                    </div>
                    <button class="modal-close" @click="closeModal">√ó</button>
                </div>
                <div class="modal-body">
                    <div class="chart-container" v-for="tf in timeframes" :key="tf.bar">
                        <div class="chart-header">
                            <span>{{ tf.label }} Chart <span v-if="tf.candleCount" style="font-size:0.75rem;color:#586069;">({{ tf.candleCount }})</span></span>
                            <span v-if="tf.trend" :style="{ color: tf.trend === 'UP' ? '#3fb950' : '#f85149' }">
                                Supertrend: {{ tf.trend }}
                            </span>
                        </div>
                        <div :id="'chart-' + tf.bar" class="chart-wrapper"></div>
                        <div v-if="tf.loading" class="loading-overlay">
                            <div class="spinner"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted } = Vue;

        const TrendBadge = {
            props: ['trend','label'],
            template: `
                <div v-if="trend === 'Loading'" class="trend-badge skeleton" style="border:none;">
                    <div class="tf" style="visibility:hidden;">{{ label }}</div>
                    <div class="signal" style="visibility:hidden;">...</div>
                </div>
                <div v-else :class="klass" class="trend-badge">
                    <div class="tf">{{ label }}</div>
                    <div class="signal">{{ text }}</div>
                </div>
            `,
            computed: {
                klass() {
                    if (this.trend === 'UP' ) return 'buy';
                    if (this.trend === 'DOWN') return 'sell';
                    if (this.trend === 'Loading') return 'loading';
                    return 'neutral';
                },
                text() {
                    if (this.trend === 'UP') return 'BUY';
                    if (this.trend === 'DOWN') return 'SELL';
                    if (this.trend === 'Loading') return '...';
                    if (this.trend === 'Error') return 'Error';
                    return 'N/A';
                }
            }
        };

        function calculateSupertrend(ohlc, period = 10, multiplier = 3) {
            if (ohlc.length < period + 1) return 'N/A';

            const high = ohlc.map(c => c.high);
            const low = ohlc.map(c => c.low);
            const close = ohlc.map(c => c.close);

            const tr = [];
            for (let i = 0; i < ohlc.length; i++) {
                if (i === 0) {
                    tr.push(high[i] - low[i]);
                } else {
                    const tr1 = high[i] - low[i];
                    const tr2 = Math.abs(high[i] - close[i - 1]);
                    const tr3 = Math.abs(low[i] - close[i - 1]);
                    tr.push(Math.max(tr1, tr2, tr3));
                }
            }

            const atr = [];
            let prevAtr = tr[0];
            atr.push(prevAtr);
            const alpha = 1 / period;
            for (let i = 1; i < tr.length; i++) {
                const curAtr = alpha * tr[i] + (1 - alpha) * prevAtr;
                atr.push(curAtr);
                prevAtr = curAtr;
            }

            const basicUpper = [];
            const basicLower = [];
            for (let i = 0; i < ohlc.length; i++) {
                const hl2 = (high[i] + low[i]) / 2;
                basicUpper.push(hl2 + multiplier * atr[i]);
                basicLower.push(hl2 - multiplier * atr[i]);
            }

            const finalUpper = [];
            const finalLower = [];
            const supertrend = [];
            const trend = [];

            finalUpper[0] = basicUpper[0];
            finalLower[0] = basicLower[0];
            supertrend[0] = finalLower[0];
            trend[0] = true;

            for (let i = 1; i < ohlc.length; i++) {
                if (basicUpper[i] < finalUpper[i - 1] || close[i - 1] > finalUpper[i - 1]) {
                    finalUpper[i] = basicUpper[i];
                } else {
                    finalUpper[i] = finalUpper[i - 1];
                }

                if (basicLower[i] > finalLower[i - 1] || close[i - 1] < finalLower[i - 1]) {
                    finalLower[i] = basicLower[i];
                } else {
                    finalLower[i] = finalLower[i - 1];
                }

                if (supertrend[i - 1] === finalUpper[i - 1] && close[i] <= finalUpper[i]) {
                    trend[i] = false;
                    supertrend[i] = finalUpper[i];
                } else if (supertrend[i - 1] === finalUpper[i - 1] && close[i] > finalUpper[i]) {
                    trend[i] = true;
                    supertrend[i] = finalLower[i];
                } else if (supertrend[i - 1] === finalLower[i - 1] && close[i] >= finalLower[i]) {
                    trend[i] = true;
                    supertrend[i] = finalLower[i];
                } else if (supertrend[i - 1] === finalLower[i - 1] && close[i] < finalLower[i]) {
                    trend[i] = false;
                    supertrend[i] = finalUpper[i];
                } else {
                    if (close[i] > finalUpper[i - 1]) {
                        trend[i] = true;
                    } else if (close[i] < finalLower[i - 1]) {
                        trend[i] = false;
                    } else {
                        trend[i] = trend[i - 1];
                    }
                    supertrend[i] = trend[i] ? finalLower[i] : finalUpper[i];
                }
            }

            return trend[trend.length - 1] ? 'UP' : 'DOWN';
        }

        async function fetchOkxTickers() {
            const url = 'https://www.okx.com/api/v5/market/tickers?instType=SPOT';
            const res = await fetch(url);
            const json = await res.json();
            if (json.code !== '0') throw new Error('OKX tickers error: ' + JSON.stringify(json));
            return json.data;
        }

        async function fetchOkxCandles(instId, bar, limit = 100) {
            const url = `https://www.okx.com/api/v5/market/candles?instId=${encodeURIComponent(instId)}&bar=${encodeURIComponent(bar)}&limit=${limit}`;
            const res = await fetch(url);
            if (!res.ok) throw new Error('HTTP ' + res.status);
            const json = await res.json();
            if (json.code !== '0') throw new Error('OKX candles error: ' + JSON.stringify(json));
            const candles = json.data || [];
            if (!candles.length) return null;

            const ohlc = candles.map(c => ({
                ts: Number(c[0]),
                open: Number(c[1]),
                high: Number(c[2]),
                low: Number(c[3]),
                close: Number(c[4])
            })).sort((a, b) => a.ts - b.ts);

            return ohlc;
        }

        function calculateSupertrendFull(ohlc, period = 10, multiplier = 3) {
            if (!ohlc || ohlc.length < period + 1) return null;

            const high = ohlc.map(c => c.high);
            const low = ohlc.map(c => c.low);
            const close = ohlc.map(c => c.close);

            const tr = [];
            for (let i = 0; i < ohlc.length; i++) {
                if (i === 0) {
                    tr.push(high[i] - low[i]);
                } else {
                    const tr1 = high[i] - low[i];
                    const tr2 = Math.abs(high[i] - close[i - 1]);
                    const tr3 = Math.abs(low[i] - close[i - 1]);
                    tr.push(Math.max(tr1, tr2, tr3));
                }
            }

            const atr = [];
            let prevAtr = tr[0];
            atr.push(prevAtr);
            const alpha = 1 / period;
            for (let i = 1; i < tr.length; i++) {
                const curAtr = alpha * tr[i] + (1 - alpha) * prevAtr;
                atr.push(curAtr);
                prevAtr = curAtr;
            }

            const basicUpper = [];
            const basicLower = [];
            for (let i = 0; i < ohlc.length; i++) {
                const hl2 = (high[i] + low[i]) / 2;
                basicUpper.push(hl2 + multiplier * atr[i]);
                basicLower.push(hl2 - multiplier * atr[i]);
            }

            const finalUpper = [];
            const finalLower = [];
            const supertrend = [];
            const trend = []; // true for UP, false for DOWN

            finalUpper[0] = basicUpper[0];
            finalLower[0] = basicLower[0];
            supertrend[0] = finalLower[0];
            trend[0] = true;

            for (let i = 1; i < ohlc.length; i++) {
                if (basicUpper[i] < finalUpper[i - 1] || close[i - 1] > finalUpper[i - 1]) {
                    finalUpper[i] = basicUpper[i];
                } else {
                    finalUpper[i] = finalUpper[i - 1];
                }

                if (basicLower[i] > finalLower[i - 1] || close[i - 1] < finalLower[i - 1]) {
                    finalLower[i] = basicLower[i];
                } else {
                    finalLower[i] = finalLower[i - 1];
                }

                if (supertrend[i - 1] === finalUpper[i - 1] && close[i] <= finalUpper[i]) {
                    trend[i] = false;
                    supertrend[i] = finalUpper[i];
                } else if (supertrend[i - 1] === finalUpper[i - 1] && close[i] > finalUpper[i]) {
                    trend[i] = true;
                    supertrend[i] = finalLower[i];
                } else if (supertrend[i - 1] === finalLower[i - 1] && close[i] >= finalLower[i]) {
                    trend[i] = true;
                    supertrend[i] = finalLower[i];
                } else if (supertrend[i - 1] === finalLower[i - 1] && close[i] < finalLower[i]) {
                    trend[i] = false;
                    supertrend[i] = finalUpper[i];
                } else {
                    // Fallback logic
                    if (close[i] > finalUpper[i - 1]) {
                        trend[i] = true;
                    } else if (close[i] < finalLower[i - 1]) {
                        trend[i] = false;
                    } else {
                        trend[i] = trend[i - 1];
                    }
                    supertrend[i] = trend[i] ? finalLower[i] : finalUpper[i];
                }
            }

            return {
                direction: trend[trend.length - 1] ? 'UP' : 'DOWN',
                supertrendSeries: ohlc.map((c, i) => ({
                    time: Math.floor(c.ts / 1000) + 28800, // UTC+8 (Beijing Time)
                    value: supertrend[i],
                    color: trend[i] ? '#22c55e' : '#ef4444'
                })),
                candles: ohlc.map(c => ({
                    time: Math.floor(c.ts / 1000) + 28800, // UTC+8 (Beijing Time)
                    open: c.open,
                    high: c.high,
                    low: c.low,
                    close: c.close
                }))
            };
        }

        function calculateRSI(ohlc, period = 14) {
            if (!ohlc || ohlc.length < period + 1) return [];
            
            const closes = ohlc.map(c => c.close);
            const rsi = [];
            
            // Calculate initial average gain/loss
            let gainSum = 0;
            let lossSum = 0;
            
            for (let i = 1; i <= period; i++) {
                const change = closes[i] - closes[i - 1];
                if (change >= 0) gainSum += change;
                else lossSum += Math.abs(change);
            }
            
            let avgGain = gainSum / period;
            let avgLoss = lossSum / period;
            
            // First RSI
            let rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            rsi[period] = 100 - (100 / (1 + rs));
            
            // Subsequent RSIs
            for (let i = period + 1; i < closes.length; i++) {
                const change = closes[i] - closes[i - 1];
                const currentGain = change > 0 ? change : 0;
                const currentLoss = change < 0 ? Math.abs(change) : 0;
                
                avgGain = (avgGain * (period - 1) + currentGain) / period;
                avgLoss = (avgLoss * (period - 1) + currentLoss) / period;
                
                rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                rsi[i] = 100 - (100 / (1 + rs));
            }
            
            // Map back to time
            return ohlc.map((c, i) => {
                if (i < period) return null;
                return {
                    time: Math.floor(c.ts / 1000) + 28800, // UTC+8
                    value: rsi[i]
                };
            }).filter(item => item !== null);
        }

        createApp({
            components: { TrendBadge },
            setup() {
                const coins = ref([]);
                const loading = ref(false);
                const lastUpdated = ref(null);
                const searchQuery = ref('');
                const sortKey = ref('rank');
                const sortOrder = ref('asc');
                const filterStatus = ref('all');
                const selectedCoins = ref(new Set());
                const viewMode = ref('all');

                const loadSelection = () => {
                    const saved = localStorage.getItem('selectedCoins');
                    if (saved) {
                        try {
                            selectedCoins.value = new Set(JSON.parse(saved));
                        } catch (e) {
                            console.error('Failed to load selection', e);
                        }
                    }
                };

                const saveSelection = () => {
                    localStorage.setItem('selectedCoins', JSON.stringify([...selectedCoins.value]));
                };

                const toggleSelection = (coin) => {
                    const newSet = new Set(selectedCoins.value);
                    if (newSet.has(coin.symbol)) {
                        newSet.delete(coin.symbol);
                    } else {
                        newSet.add(coin.symbol);
                    }
                    selectedCoins.value = newSet;
                    saveSelection();
                };

                const isSelected = (coin) => selectedCoins.value.has(coin.symbol);

                const toggleViewMode = () => {
                    viewMode.value = viewMode.value === 'all' ? 'watchlist' : 'all';
                };

                const formatPrice = (price) => {
                    if (price == null || isNaN(price)) return '-';
                    if (price < 1) return price.toFixed(6);
                    if (price < 10) return price.toFixed(4);
                    return price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                };

                const lastUpdatedFormatted = computed(() => {
                    if (!lastUpdated.value) return '‰ªéÊú™';
                    return new Date(lastUpdated.value).toLocaleString('zh-CN');
                });

                const filteredCoins = computed(() => {
                    let result = coins.value.slice();

                    if (searchQuery.value) {
                        const q = searchQuery.value.toLowerCase();
                        result = result.filter(c =>
                            c.name.toLowerCase().includes(q) ||
                            c.symbol.toLowerCase().includes(q)
                        );
                    }

                    if (viewMode.value === 'watchlist') {
                        result = result.filter(c => selectedCoins.value.has(c.symbol));
                    }

                    if (filterStatus.value !== 'all') {
                        result = result.filter(c => {
                            const arr = [c.trend_15m, c.trend_1h, c.trend_4h, c.trend_1d];
                            const buys = arr.filter(x => x === 'UP').length;
                            const sells = arr.filter(x => x === 'DOWN').length;
                            const category = buys > sells ? 'bullish' : sells > buys ? 'bearish' : 'neutral';
                            return category === filterStatus.value;
                        });
                    }

                    result.sort((a, b) => {
                        let valA = a[sortKey.value];
                        let valB = b[sortKey.value];

                        if (typeof valA === 'string') valA = valA.toLowerCase();
                        if (typeof valB === 'string') valB = valB.toLowerCase();

                        if (valA < valB) return sortOrder.value === 'asc' ? -1 : 1;
                        if (valA > valB) return sortOrder.value === 'asc' ? 1 : -1;
                        return 0;
                    });

                    return result;
                });

                const setFilter = (status) => {
                    filterStatus.value = status;
                };

                const sortBy = (key) => {
                    if (sortKey.value === key) {
                        sortOrder.value = sortOrder.value === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortKey.value = key;
                        sortOrder.value = 'asc';
                    }
                };

                const loadedCount = computed(() => {
                    return coins.value.filter(c => !['Loading'].includes(c.trend_15m) && !['Loading'].includes(c.trend_1h) && !['Loading'].includes(c.trend_4h) && !['Loading'].includes(c.trend_1d)).length;
                });

                const loadPercent = computed(() => {
                    if (!coins.value.length) return 0;
                    return Math.round((loadedCount.value / coins.value.length) * 100);
                });

                const stats = computed(() => {
                    let bullish = 0, bearish = 0, neutral = 0;
                    coins.value.forEach(c => {
                        const arr = [c.trend_15m, c.trend_1h, c.trend_4h, c.trend_1d];
                        const buys = arr.filter(x => x === 'UP').length;
                        const sells = arr.filter(x => x === 'DOWN').length;
                        if (buys > sells) bullish++;
                        else if (sells > buys) bearish++;
                        else neutral++;
                    });
                    return { bullish, bearish, neutral };
                });

                function scoreInfo(coin) {
                    const arr = [coin.trend_15m, coin.trend_1h, coin.trend_4h, coin.trend_1d, coin.trend_1w];
                    const buys = arr.filter(x => x === 'UP').length;
                    const sells = arr.filter(x => x === 'DOWN').length;
                    const diff = buys - sells;
                    if (diff >= 2) return { label: 'Âº∫ÁúãÊ∂®', klass: 'score-strong-buy' };
                    if (diff === 1) return { label: 'ÁúãÊ∂®', klass: 'score-buy' };
                    if (diff === 0) return { label: '‰∏≠ÊÄß', klass: 'score-neutral' };
                    if (diff === -1) return { label: 'ÁúãË∑å', klass: 'score-sell' };
                    return { label: 'Âº∫ÁúãË∑å', klass: 'score-strong-sell' };
                }

                function generateMiniChart(coin) {
                    if (!coin) return '<div class="mini-chart skeleton"></div>';
                    if (!coin.sparkline || coin.sparkline.length < 2) return '<div class="mini-chart skeleton"></div>';
                    
                    const values = coin.sparkline;
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    const range = max - min || 1;
                    
                    const width = 120;
                    const height = 40;
                    const padding = 2;
                    
                    // ÂùêÊ†áËÆ°ÁÆó
                    const points = values.map((v, i) => {
                        const x = (i / (values.length - 1)) * width;
                        const y = height - padding - ((v - min) / range) * (height - 2 * padding);
                        return `${x},${y}`;
                    }).join(' ');

                    const isUp = values[values.length - 1] >= values[0];
                    const strokeColor = isUp ? '#22c55e' : '#ef4444';
                    const fillColor = isUp ? '#22c55e' : '#ef4444';
                    
                    // Ê∏êÂèòÂ°´ÂÖÖË∑ØÂæÑ (Èó≠ÂêàÂà∞Â∫ïÈÉ®)
                    // points format: "x1,y1 x2,y2 ..."
                    // We need to ensure the path syntax is robust
                    const firstPoint = points.split(' ')[0];
                    const fillPath = `M0,${height} L${firstPoint} ${points} L${width},${height} Z`;

                    return `
                        <svg class="mini-chart" viewBox="0 0 ${width} ${height}" preserveAspectRatio="none">
                            <defs>
                                <linearGradient id="grad-${coin.symbol}" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" stop-color="${fillColor}" stop-opacity="0.3"/>
                                    <stop offset="100%" stop-color="${fillColor}" stop-opacity="0.0"/>
                                </linearGradient>
                            </defs>
                            <path d="${fillPath}" fill="url(#grad-${coin.symbol})" stroke="none" />
                            <polyline points="${points}" fill="none" stroke="${strokeColor}" stroke-width="2" stroke-linejoin="round" stroke-linecap="round"/>
                        </svg>
                    `;
                }

                function coinIconUrl(symbol) {
                    if (!symbol) return '';
                    return `https://assets.coincap.io/assets/icons/${symbol.toLowerCase()}@2x.png`;
                }

                function coinColor(symbol) {
                    const colors = { BTC:'#F7931A', ETH:'#627EEA', BNB:'#F3BA2F', XRP:'#23292F', SOL:'#00FFA3' };
                    if (colors[symbol]) return colors[symbol];
                    let hash = 0;
                    for (let i=0;i<symbol.length;i++) hash = symbol.charCodeAt(i) + ((hash<<5) - hash);
                    const hue = Math.abs(hash) % 360;
                    return `hsl(${hue}, 60%, 50%)`;
                }

                const showModal = ref(false);
                const activeCoin = ref({});
                const sentiment = ref(null);
                const timeframes = ref([
                    { bar: '15m', label: '15M', loading: false, trend: '', candleCount: 0 },
                    { bar: '1H', label: '1H', loading: false, trend: '', candleCount: 0 },
                    { bar: '4H', label: '4H', loading: false, trend: '', candleCount: 0 },
                    { bar: '1D', label: '1D', loading: false, trend: '', candleCount: 0 },
                    { bar: '1W', label: '1W', loading: false, trend: '', candleCount: 0 }
                ]);
                const chartInstances = {};

                const fetchSentiment = async () => {
                    try {
                        const res = await fetch('https://api.alternative.me/fng/?limit=2');
                        const json = await res.json();
                        if (json.data && json.data.length >= 2) {
                            const today = json.data[0];
                            const yesterday = json.data[1];
                            const val = parseInt(today.value);
                            
                            // Generate analysis based on value
                            let analysis = [];
                            let prediction = [];
                            let advice = "";

                            if (val <= 25) { // Extreme Fear
                                analysis = ["Â∏ÇÂú∫Â§Ñ‰∫éÊûÅÂ∫¶ÊÅêÊÉßÁä∂ÊÄÅÔºåÊÅêÊÖåÁõòÊ∂åÂá∫", "È£éÈô©ÂÅèÂ•ΩÊûÅ‰ΩéÔºåÂ§ßÈÉ®ÂàÜÊäïËµÑËÄÖÈÄâÊã©ËßÇÊúõ"];
                                prediction = ["Áü≠ÊúüÂèØËÉΩÁªßÁª≠‰∏ãÊé¢ÂØªÊâæÂ∫ïÈÉ®ÊîØÊíë", "‰ΩÜ‰πüÂèØËÉΩËøéÊù•Ë∂ÖË∑åÂèçÂºπÁöÑÊú∫‰ºö"];
                                advice = "Âà´‰∫∫ÊÅêÊÉßÊàëË¥™Â©™ÔºåÂèØËÄÉËôëÂú®ÂÖ≥ÈîÆÊîØÊíë‰ΩçÂàÜÊâπÂª∫‰ªì‰ºòË¥®ËµÑ‰∫ßÔºåÂàáÂãøËøΩÊ∂®ÊùÄË∑å„ÄÇ";
                            } else if (val <= 45) { // Fear
                                analysis = ["Â∏ÇÂú∫ÊÉÖÁª™ÂÅèÂêëË∞®ÊÖéÔºåÂ§öÁ©∫ÂçöÂºàÊøÄÁÉà", "Â∞öÊú™ÂΩ¢ÊàêÊòéÁ°ÆÁöÑ‰∏äÊ∂®ÂêàÂäõ"];
                                prediction = ["È¢ÑËÆ°Â∏ÇÂú∫Â∞ÜÂú®ÈúáËç°‰∏≠ÂØªÊâæÊñπÂêë", "ÂÖ≥Ê≥®‰∏ªÂäõËµÑÈáëÂä®Âêë"];
                                advice = "‰øùÊåÅËÄêÂøÉÔºåÂÖ≥Ê≥®Âü∫Êú¨Èù¢ËâØÂ•ΩÁöÑÂ∏ÅÁßçÔºåÂèØÈááÂèñÂÆöÊäïÁ≠ñÁï•Âπ≥ÊëäÊàêÊú¨„ÄÇ";
                            } else if (val <= 55) { // Neutral
                                analysis = ["Â§öÁ©∫ÂäõÈáèÂùáË°°ÔºåÂ∏ÇÂú∫Áº∫‰πèÊòéÁ°ÆÊåáÂºï", "‰∫§ÊòìÈáèÂèØËÉΩÁõ∏ÂØπÂπ≥Ê∑°"];
                                prediction = ["Ê®™ÁõòÊï¥ÁêÜÊ¶ÇÁéáËæÉÂ§ß", "Á≠âÂæÖÁ™ÅÁ†¥‰ø°Âè∑Âá∫Áé∞"];
                                advice = "ËßÇÊúõ‰∏∫‰∏ªÔºåÂáèÂ∞ëÊìç‰ΩúÈ¢ëÁéáÔºåÁ≠âÂæÖË∂ãÂäøÊòéÊúóÂêéÂÜçÂÖ•Âú∫„ÄÇ";
                            } else if (val <= 75) { // Greed
                                analysis = ["Â∏ÇÂú∫ÊÉÖÁª™ÂõûÊöñÔºå‰π∞ÁõòÈÄêÊ∏êÂ¢ûÂº∫", "ËµöÈí±ÊïàÂ∫îÊòæÁé∞ÔºåÂê∏ÂºïÂú∫Â§ñËµÑÈáëÂÖ•Âú∫"];
                                prediction = ["Áü≠ÊúüË∂ãÂäøÂêë‰∏äÔºå‰ΩÜÈúÄË≠¶ÊÉïËé∑Âà©ÁõòÂõûÂêê", "ÊùøÂùóËΩÆÂä®ÂèØËÉΩÂä†Âø´"];
                                advice = "È°∫ÂäøËÄå‰∏∫ÔºåÊåÅÊúâÊ†∏ÂøÉ‰ªì‰ΩçÔºåÂèØÈÄÇÂΩìÂèÇ‰∏éÁÉ≠ÁÇπÊùøÂùóÁÇí‰ΩúÔºåËÆæÁΩÆÂ•ΩÊ≠¢Áõà‰Ωç„ÄÇ";
                            } else { // Extreme Greed
                                analysis = ["Â∏ÇÂú∫Â§Ñ‰∫éÊûÅÂ∫¶Ë¥™Â©™Áä∂ÊÄÅÔºåFOMOÊÉÖÁª™È´òÊ∂®", "È£éÈô©Á¥ØÁßØËæÉÈ´òÔºåÈöèÊó∂ÂèØËÉΩÂá∫Áé∞ÂõûË∞É"];
                                prediction = ["Âä†ÈÄüÂÜ≤È°∂ÂêéÂèØËÉΩÂá∫Áé∞ÂâßÁÉàÊ≥¢Âä®", "Ë∞®Èò≤‰∏ªÂäõÈ´ò‰ΩçÂá∫Ë¥ß"];
                                advice = "Âà´‰∫∫Ë¥™Â©™ÊàëÊÅêÊÉßÔºåÂª∫ËÆÆÂàÜÊâπÊ≠¢ÁõàÔºåÈôç‰Ωé‰ªì‰ΩçÔºåËêΩË¢ã‰∏∫ÂÆâÔºåÂàáÂãøÁõ≤ÁõÆÂä†Êù†ÊùÜ„ÄÇ";
                            }

                            sentiment.value = {
                                today,
                                yesterday,
                                analysis,
                                prediction,
                                advice
                            };
                        } else {
                            throw new Error('Invalid data');
                        }
                    } catch (e) {
                        console.error('Fetch sentiment error', e);
                        // Fallback data
                        sentiment.value = {
                            today: { value: "50", value_classification: "Neutral" },
                            yesterday: { value: "50", value_classification: "Neutral" },
                            analysis: ["Êó†Ê≥ïËé∑ÂèñÊúÄÊñ∞Â∏ÇÂú∫ÊÉÖÁª™Êï∞ÊçÆ", "ËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÊàñÁ®çÂêéÈáçËØï"],
                            prediction: ["Êï∞ÊçÆÊöÇÊó∂‰∏çÂèØÁî®", "Âª∫ËÆÆÂèÇËÄÉÊäÄÊúØÊåáÊ†áËøõË°åÂà§Êñ≠"],
                            advice: "Êé•Âè£ËØ∑Ê±ÇÂ§±Ë¥•ÔºåÊöÇÊó∂Êó†Ê≥ïÊèê‰æõÊìç‰ΩúÂª∫ËÆÆ„ÄÇ"
                        };
                    }
                };

                const getSentimentClass = (val) => {
                    val = parseInt(val);
                    if (val <= 25) return 'fng-extreme-fear';
                    if (val <= 45) return 'fng-fear';
                    if (val <= 55) return 'fng-neutral';
                    if (val <= 75) return 'fng-greed';
                    return 'fng-extreme-greed';
                };

                const getSentimentColor = (val) => {
                    val = parseInt(val);
                    if (val <= 25) return '#3fb950'; // Extreme Fear (Green for buy opportunity)
                    if (val <= 45) return '#a371f7'; // Fear
                    if (val <= 55) return '#d29922'; // Neutral
                    if (val <= 75) return '#f85149'; // Greed
                    return '#da3633'; // Extreme Greed
                };

                const getSentimentEmoji = (classification) => {
                    if (classification.includes('Extreme Fear')) return 'üò±';
                    if (classification.includes('Fear')) return 'üò®';
                    if (classification.includes('Neutral')) return 'üòê';
                    if (classification.includes('Extreme Greed')) return 'ü§ë';
                    if (classification.includes('Greed')) return 'üòÉ';
                    return '';
                };

                const getSentimentChange = (today, yesterday) => {
                    const diff = parseInt(today) - parseInt(yesterday);
                    if (diff > 0) return `+${diff} (‰∏äÂçá üîº)`;
                    if (diff < 0) return `${diff} (‰∏ãÈôç üîΩ)`;
                    return `0 (ÊåÅÂπ≥ ‚ûñ)`;
                };

                const openChart = (coin) => {
                    activeCoin.value = coin;
                    showModal.value = true;
                    // Reset states
                    timeframes.value.forEach(tf => {
                        tf.loading = true;
                        tf.trend = '';
                        tf.candleCount = 0;
                    });
                    // Wait for modal to render
                    setTimeout(() => {
                        renderCharts(coin);
                    }, 100);
                };

                const closeModal = () => {
                    showModal.value = false;
                    // Cleanup charts
                    Object.keys(chartInstances).forEach(key => {
                        try {
                            if (chartInstances[key]) {
                                chartInstances[key].remove();
                            }
                        } catch(e) {
                            console.warn('Cleanup chart error', e);
                        }
                        delete chartInstances[key];
                    });
                };

                const renderCharts = async (coin) => {
                    await Vue.nextTick();
                    await new Promise(r => setTimeout(r, 300));

                    if (typeof LightweightCharts === 'undefined') {
                        console.error('LightweightCharts library not loaded');
                        return;
                    }

                    for (const tf of timeframes.value) {
                        try {
                            const container = document.getElementById(`chart-${tf.bar}`);
                            if (!container) continue;

                            // Á°Æ‰øùÂÆπÂô®ÊúâÂÆΩÂ∫¶ÔºåÂ¶ÇÊûú‰∏∫0ÂàôÂ∞ùËØïËé∑ÂèñÁà∂Á∫ßÂÆΩÂ∫¶
                            let width = container.clientWidth;
                            if (!width || width < 100) width = container.parentElement ? container.parentElement.clientWidth - 40 : 800;
                            
                            // Â¢ûÂä†ÈáçËØïÈÄªËæëÈÅøÂÖç 429
                            let ohlc = null;
                            let retries = 3;
                            while(retries > 0) {
                                try {
                                    // Â¢ûÂä†ËØ∑Ê±ÇÈó¥ÈöîÔºåÈÅøÂÖçËß¶ÂèëÈ¢ëÁéáÈôêÂà∂
                                    if (timeframes.value.indexOf(tf) > 0) {
                                        await new Promise(r => setTimeout(r, 300));
                                    }
                                    ohlc = await fetchOkxCandles(coin.instId, tf.bar, 300);
                                    if (ohlc) break;
                                } catch (err) {
                                    if (err.message.includes('429')) {
                                        await new Promise(r => setTimeout(r, 1000 + Math.random() * 500));
                                        retries--;
                                        continue;
                                    }
                                    break;
                                }
                                retries--;
                            }

                            if (!ohlc || ohlc.length === 0) {
                                tf.loading = false;
                                tf.trend = 'No Data';
                                container.innerHTML = '<div style="display:flex;justify-content:center;align-items:center;height:100%;color:#8b949e;flex-direction:column;gap:10px;"><span style="font-size:2rem;">üìâ</span><span>ÊöÇÊó† K Á∫øÊï∞ÊçÆ</span></div>';
                                continue;
                            }
                            
                            const data = calculateSupertrendFull(ohlc, 10, 3);
                            if (!data) {
                                tf.loading = false;
                                tf.trend = 'Calc Error';
                                container.innerHTML = '<div style="display:flex;justify-content:center;align-items:center;height:100%;color:#f85149;flex-direction:column;gap:10px;"><span style="font-size:2rem;">‚ö†Ô∏è</span><span>ËÆ°ÁÆóÊåáÊ†áÂá∫Èîô (Êï∞ÊçÆ‰∏çË∂≥)</span></div>';
                                continue;
                            }

                            tf.trend = data.direction;
                            
                            // Basic validation
                            const validCandles = [];
                            const seenTimes = new Set();
                            
                            data.candles.forEach(c => {
                                if (seenTimes.has(c.time)) return;
                                if (c.time && !isNaN(c.open) && !isNaN(c.high) && !isNaN(c.low) && !isNaN(c.close)) {
                                    validCandles.push(c);
                                    seenTimes.add(c.time);
                                }
                            });
                            
                            validCandles.sort((a, b) => a.time - b.time);
                            tf.candleCount = validCandles.length;

                            if (validCandles.length === 0) {
                                tf.loading = false;
                                container.innerHTML = '<div style="display:flex;justify-content:center;align-items:center;height:100%;color:#8b949e;">Êó†ÊúâÊïà K Á∫øÊï∞ÊçÆ</div>';
                                continue;
                            }

                            // Clean up existing only when we are ready to render
                            try {
                                if (chartInstances[tf.bar]) {
                                    chartInstances[tf.bar].remove();
                                }
                            } catch(e) {
                                console.warn('Remove existing chart error', e);
                            }
                            delete chartInstances[tf.bar];
                            container.innerHTML = '';

                            const chart = LightweightCharts.createChart(container, {
                                width: width,
                                height: 380,
                                layout: {
                                    background: { type: 'solid', color: '#0d1117' },
                                    textColor: '#8b949e',
                                },
                                grid: {
                                    vertLines: { color: '#21262d' },
                                    horzLines: { color: '#21262d' },
                                },
                                localization: {
                                    locale: 'zh-CN',
                                    timeFormatter: (timestamp) => {
                                        const date = new Date(timestamp * 1000);
                                        const y = date.getUTCFullYear();
                                        const m = date.getUTCMonth() + 1;
                                        const d = date.getUTCDate();
                                        const h = date.getUTCHours();
                                        const min = date.getUTCMinutes();
                                        const pad = (n) => n.toString().padStart(2, '0');
                                        return `${y}Âπ¥${m}Êúà${d}Êó• ${pad(h)}:${pad(min)}`;
                                    }
                                },
                                timeScale: {
                                    timeVisible: true,
                                    secondsVisible: false,
                                    borderColor: '#30363d',
                                },
                                rightPriceScale: {
                                    borderColor: '#30363d',
                                    scaleMargins: {
                                        top: 0.05,
                                        bottom: 0.25, // Leave space for RSI
                                    },
                                },
                            });

                            // Add custom price scale for RSI
                            chart.priceScale('rsi').applyOptions({
                                scaleMargins: {
                                    top: 0.8, // Position at bottom
                                    bottom: 0,
                                },
                            });

                            const candlestickSeries = chart.addCandlestickSeries({
                                upColor: '#238636',
                                downColor: '#da3633',
                                borderVisible: false,
                                wickUpColor: '#238636',
                                wickDownColor: '#da3633',
                            });

                            candlestickSeries.setData(validCandles);

                            // Calculate and add RSI
                            const rsiData = calculateRSI(ohlc, 14);
                            if (rsiData.length > 0) {
                                const rsiSeries = chart.addLineSeries({
                                    color: '#7e22ce', // Purple-ish
                                    lineWidth: 2,
                                    priceScaleId: 'rsi',
                                    lastValueVisible: false,
                                    priceLineVisible: false,
                                });
                                rsiSeries.setData(rsiData);
                                
                                // Add RSI Thresholds
                                rsiSeries.createPriceLine({
                                    price: 70,
                                    color: '#f85149',
                                    lineWidth: 1,
                                    lineStyle: LightweightCharts.LineStyle.Dashed,
                                    axisLabelVisible: false,
                                });
                                rsiSeries.createPriceLine({
                                    price: 30,
                                    color: '#3fb950',
                                    lineWidth: 1,
                                    lineStyle: LightweightCharts.LineStyle.Dashed,
                                    axisLabelVisible: false,
                                });
                                rsiSeries.createPriceLine({
                                    price: 50,
                                    color: '#8b949e',
                                    lineWidth: 1,
                                    lineStyle: LightweightCharts.LineStyle.Dotted,
                                    axisLabelVisible: false,
                                });
                            }

                            // Â§ÑÁêÜ Supertrend Á∫øÊï∞ÊçÆÔºöÂêàÂπ∂‰∏∫ÂçïÊù°Á∫ø‰ª•ÈÅøÂÖçÊñ≠Ë£Ç
                            const stData = [];
                            
                            // ÂàõÂª∫ÂÆåÊï¥ÁöÑ timeline map ‰ª•‰æø‰∫éÊü•Êâæ
                            const stMap = new Map();
                            data.supertrendSeries.forEach(item => {
                                stMap.set(item.time, item);
                            });

                            // ÈÅçÂéÜÊâÄÊúâÊúâÊïà K Á∫øÊó∂Èó¥ÁÇπÔºåÁ°Æ‰øùÊï∞ÊçÆÂØπÈΩê
                            validCandles.forEach(c => {
                                const item = stMap.get(c.time);
                                if (item && !isNaN(item.value)) {
                                    stData.push({ 
                                        time: c.time, 
                                        value: item.value,
                                        color: item.color // Áõ¥Êé•‰ΩøÁî®ËÆ°ÁÆóÂ•ΩÁöÑÈ¢úËâ≤
                                    });
                                }
                            });

                            if(stData.length > 0) {
                                const stSeries = chart.addLineSeries({
                                    lineWidth: 2,
                                    priceLineVisible: false,
                                    lastValueVisible: false,
                                    crosshairMarkerVisible: false,
                                });
                                stSeries.setData(stData);

                                // Add Supertrend Legend
                                const lastSt = stData[stData.length - 1];
                                // We can infer direction from color since we set it in calculateSupertrendFull
                                const isUp = lastSt.color === '#22c55e'; 
                                const label = isUp ? 'Support' : 'Resistance';
                                const color = isUp ? '#3fb950' : '#f85149';
                                const formattedPrice = formatPrice(lastSt.value);

                                const legend = document.createElement('div');
                                legend.className = 'chart-supertrend-legend';
                                legend.style.borderColor = 'rgba(48, 54, 61, 0.5)'; // Keep border subtle or match color? User asked for colored text maybe. Let's keep border neutral or colored.
                                // Let's use the color for the text and dot
                                legend.innerHTML = `
                                    <div class="st-legend-dot" style="background: ${color}"></div>
                                    <span style="color: ${color}">${label}: ${formattedPrice}</span>
                                `;
                                container.appendChild(legend);
                            }

                            chartInstances[tf.bar] = chart;

                            const resizeObserver = new ResizeObserver(entries => {
                                if (entries.length === 0 || entries[0].target !== container) return;
                                const newRect = entries[0].contentRect;
                                if (newRect.width === 0 || newRect.height === 0) return;
                                chart.applyOptions({ width: newRect.width });
                            });
                            resizeObserver.observe(container);

                            // Force fit content after a slight delay to ensure rendering
                            setTimeout(() => {
                                chart.timeScale().fitContent();
                            }, 50);

                        } catch (e) {
                            console.error(`Chart render error ${tf.bar}`, e);
                            tf.trend = 'Error';
                        } finally {
                            tf.loading = false;
                        }
                    }
                };

                const fetchData = async () => {
                    loading.value = true;
                    try {
                        const tickers = await fetchOkxTickers();
                        const usdtTickers = tickers.filter(t =>
                            typeof t.instId === 'string' && t.instId.endsWith('-USDT')
                        );

                        usdtTickers.sort((a, b) => {
                            const va = Number(a.volCcy24h || 0);
                            const vb = Number(b.volCcy24h || 0);
                            return vb - va;
                        });

                        const top = usdtTickers.slice(0, 250);

                        // Create a map of existing coins to preserve their state
                        const existingCoinsMap = new Map();
                        if (coins.value && coins.value.length > 0) {
                            coins.value.forEach(c => existingCoinsMap.set(c.symbol, c));
                        }

                        const baseCoins = top.map((t, idx) => {
                            const instId = t.instId;
                            const base = instId.split('-')[0];
                            const price = Number(t.last || 0);
                            // sodUtc8 is Open price at UTC+8 (Beijing Time 00:00)
                            const openUtc8 = Number(t.sodUtc8 || t.open24h || price);
                            const changePercent = openUtc8 ? ((price - openUtc8) / openUtc8) * 100 : 0;

                            const existing = existingCoinsMap.get(base);

                            return {
                                rank: idx + 1,
                                name: base,
                                symbol: base,
                                price,
                                changePercent,
                                image: coinIconUrl(base),
                                // Preserve existing trends if available, otherwise 'Loading'
                                trend_15m: existing ? existing.trend_15m : 'Loading',
                                trend_1h: existing ? existing.trend_1h : 'Loading',
                                trend_4h: existing ? existing.trend_4h : 'Loading',
                                trend_1d: existing ? existing.trend_1d : 'Loading',
                                trend_1w: existing ? existing.trend_1w : 'Loading',
                                sparkline: existing ? existing.sparkline : [],
                                instId
                            };
                        });

                        coins.value = baseCoins;
                        lastUpdated.value = new Date().toISOString();

                        const tasks = [];
                        const bars = [
                            { bar: '15m', key: 'trend_15m' },
                            { bar: '1H', key: 'trend_1h' },
                            { bar: '4H', key: 'trend_4h' },
                            { bar: '1D', key: 'trend_1d' },
                            { bar: '1W', key: 'trend_1w' }
                        ];

                        baseCoins.forEach((coin, index) => {
                            bars.forEach(({ bar, key }) => {
                                tasks.push({ index, instId: coin.instId, bar, key });
                            });
                        });

                        // üü¢ Architecture Optimization: Fixed Concurrency Worker Pool
                        // Replaces unstable dynamic scheduler with a robust, zero-delay worker system
                        // Optimized for browser limit (HTTP/1.1 ~6 conns, HTTP/2 multiplexing support)
                        
                        const CONCURRENCY = 8; // Stable "Sweet Spot" for max throughput
                        let cursor = 0;
                        let pausedUntil = 0; // Global pause timestamp for rate limiting

                        const worker = async () => {
                            while (cursor < tasks.length) {
                                // Rate Limit Check
                                if (Date.now() < pausedUntil) {
                                    await new Promise(r => setTimeout(r, pausedUntil - Date.now()));
                                }

                                const task = tasks[cursor++];
                                if (!task) break; // Safety check

                                try {
                                    // Fetch logic with immediate execution (No artificial delays)
                                    let ohlc = null;
                                    let retries = 3;
                                    
                                    while (retries > 0) {
                                        try {
                                            ohlc = await fetchOkxCandles(task.instId, task.bar);
                                            break; // Success
                                        } catch (err) {
                                            if (err.message && err.message.includes('429')) {
                                                // Global Pause Signal
                                                console.warn('Rate limit hit, pausing all workers...');
                                                pausedUntil = Date.now() + 2000 + Math.random() * 1000;
                                                await new Promise(r => setTimeout(r, 2000)); // Wait locally too
                                            } else {
                                                await new Promise(r => setTimeout(r, 1000)); // Network error backoff
                                            }
                                            retries--;
                                        }
                                    }

                                    // Data Processing (Optimized)
                                    let trend = 'Error';
                                    if (ohlc && ohlc.length) {
                                        trend = calculateSupertrend(ohlc, 10, 3);
                                        
                                        // Update sparkline logic
                                        let sparklineData = null;
                                        if (task.bar === '15m') sparklineData = ohlc.slice(-96).map(c => c.close);
                                        else if (task.bar === '1H') sparklineData = ohlc.slice(-24).map(c => c.close);

                                        if (sparklineData) {
                                            if (task.bar === '15m' || !coins.value[task.index].sparkline) {
                                                coins.value[task.index].sparkline = sparklineData;
                                            }
                                        } else if (!coins.value[task.index].sparkline && task.bar !== '15m' && task.bar !== '1H') {
                                            coins.value[task.index].sparkline = ohlc.slice(-24).map(c => c.close);
                                        }
                                    } else if (ohlc === null) {
                                        trend = 'N/A';
                                    }
                                    
                                    // Atomic UI Update
                                    coins.value[task.index][task.key] = trend;

                                } catch (e) {
                                    coins.value[task.index][task.key] = 'Error';
                                }
                            }
                        };

                        // Start Fixed Worker Pool
                        return Promise.all(Array(CONCURRENCY).fill(null).map(() => worker()));
                    } catch (e) {
                        console.error('Fetch error', e);
                    } finally {
                        loading.value = false;
                    }
                };

                onMounted(() => {
                    loadSelection();
                    fetchData();
                    fetchSentiment();
                    // üü¢ Increased refresh interval to 5 minutes to accommodate larger dataset (250 coins)
                    setInterval(fetchData, 300000);
                });

                return {
                    coins,
                    loading,
                    lastUpdatedFormatted,
                    searchQuery,
                    filteredCoins,
                    fetchData,
                    formatPrice,
                    sortKey,
                    sortOrder,
                    sortBy,
                    filterStatus,
                    setFilter,
                    loadedCount,
                    loadPercent,
                    stats,
                    coinColor,
                    generateMiniChart,
                    scoreInfo,
                    showModal,
                    activeCoin,
                    openChart,
                    closeModal,
                    timeframes,
                    sentiment,
                    getSentimentClass,
                    getSentimentColor,
                    getSentimentEmoji,
                    getSentimentChange,
                    selectedCoins,
                    viewMode,
                    toggleSelection,
                    isSelected,
                    toggleViewMode
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
