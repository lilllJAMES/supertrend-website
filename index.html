<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto SuperTrend Monitor</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        /* 
         * ==================================================================================
         * ã€æ ·å¼å±‚ã€‘CSS è®¾è®¡ç³»ç»Ÿ (Design System)
         * ==================================================================================
         * é‡‡ç”¨æš—è‰²ä¸»é¢˜ (Dark Mode) ä»¥é€‚åº”é•¿æ—¶é—´çœ‹ç›˜éœ€æ±‚ã€‚
         * æ ¸å¿ƒè®¾è®¡è¯­è¨€ï¼š
         * - ç»ç’ƒæ‹Ÿæ€ (Glassmorphism)ï¼šä½¿ç”¨ backdrop-filter: blur() è¥é€ ç°ä»£æ„Ÿã€‚
         * - è¯­ä¹‰åŒ–è‰²å½©ï¼š
         *   ğŸŸ¢ ç»¿è‰² (#3fb950)ï¼šä»£è¡¨ä¸Šæ¶¨ã€ä¹°å…¥ã€è´ªå©ªã€‚
         *   ğŸ”´ çº¢è‰² (#f85149)ï¼šä»£è¡¨ä¸‹è·Œã€å–å‡ºã€ææ…Œã€‚
         *   ğŸ”µ è“è‰² (#58a6ff)ï¼šä»£è¡¨ä¸­æ€§ã€åŠ è½½ã€ä¿¡æ¯ã€‚
         *   ğŸŸ¡ é»„è‰² (#d29922)ï¼šä»£è¡¨è­¦å‘Šã€æŒæœ‰ã€‚
         * ==================================================================================
         */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        [v-cloak] { display: none; }
        :root {
            --bg-color: #0b0f1e;
            --card-bg: rgba(22, 27, 34, 0.7);
            --card-border: rgba(48, 54, 61, 0.7);
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --accent-blue: #58a6ff;
            --accent-yellow: #d29922;
        }
        body { 
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Microsoft YaHei', sans-serif; 
            background: radial-gradient(1200px 500px at 10% 10%, #0b0f1e 0%, #0b0f1e 30%, #121329 60%, #131135 100%); 
            color: var(--text-primary); 
            min-height: 100vh; 
        }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #0d1117; }
        ::-webkit-scrollbar-thumb { background: #30363d; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #58a6ff; }
        
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        
        /* Modal Styles */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 1000; display: flex; justify-content: center; align-items: center; backdrop-filter: blur(8px); }
        .modal-content { background: #161b22; width: 95%; max-width: 1200px; height: 90vh; border-radius: 16px; border: 1px solid #30363d; display: flex; flex-direction: column; overflow: hidden; box-shadow: 0 20px 40px rgba(0,0,0,0.5); }
        .modal-header { padding: 20px 24px; border-bottom: 1px solid #30363d; display: flex; justify-content: space-between; align-items: center; background: #0d1117; }
        .modal-title { font-size: 1.25rem; font-weight: 700; color: #e6edf3; display: flex; align-items: center; gap: 12px; }
        .modal-close { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 50%; width: 32px; height: 32px; color: #8b949e; font-size: 1.5rem; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
        .modal-close:hover { background: rgba(248,81,73,0.2); color: #f85149; border-color: rgba(248,81,73,0.3); }
        .modal-body { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 20px; scroll-behavior: smooth; }
        
        .chart-container { background: #0d1117; border: 1px solid #30363d; border-radius: 12px; padding: 12px; display: flex; flex-direction: column; height: 420px; position: relative; box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
        .chart-header { display: flex; justify-content: space-between; margin-bottom: 12px; font-size: 0.9rem; font-weight: 600; color: #8b949e; padding: 0 10px; }
        .chart-wrapper { flex: 1; width: 100%; position: relative; }
        .loading-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(13,17,23,0.8); display: flex; justify-content: center; align-items: center; z-index: 10; color: #58a6ff; font-weight: 500; }
        
        .header { text-align: center; padding: 40px 20px 30px; margin-bottom: 20px; }
        .header h1 {
            font-size: 2.8rem;
            font-weight: 800;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, #6366f1, #a855f7, #0ea5e9);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 12px;
            text-shadow: 0 10px 30px rgba(99, 102, 241, 0.2);
        }
        .header p { color: #8b949e; font-size: 1.1rem; }
        
        .api-badge { background: linear-gradient(90deg, #238636, #2ea043); color: white; padding: 4px 10px; border-radius: 99px; font-size: 0.75rem; font-weight: 700; letter-spacing: 0.5px; box-shadow: 0 2px 5px rgba(35, 134, 54, 0.3); }
        
        .status-bar { 
            display: flex; justify-content: space-between; align-items: center; padding: 16px 24px; 
            background: var(--card-bg); border: 1px solid var(--card-border); 
            border-radius: 16px; margin-bottom: 24px; backdrop-filter: blur(10px); 
            box-shadow: 0 8px 24px rgba(0,0,0,0.2); flex-wrap: wrap; gap: 16px; 
        }
        .status-left { display: flex; align-items: center; gap: 24px; flex-wrap: wrap; color: #8b949e; font-size: 0.9rem; font-weight: 500; }
        .status-item { display: flex; align-items: center; gap: 8px; }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; background: #3fb950; box-shadow: 0 0 10px rgba(63, 185, 80, 0.5); animation: pulse 2s infinite; }
        .status-dot.loading { background: #d29922; box-shadow: 0 0 10px rgba(210, 153, 34, 0.5); }
        .status-dot.error { background: #f85149; box-shadow: 0 0 10px rgba(248, 81, 73, 0.5); animation: none; }
        @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(1.1); } }
        
        .controls { display: flex; gap: 12px; margin-bottom: 24px; flex-wrap: wrap; justify-content: center; }
        .btn { 
            padding: 10px 20px; border: 1px solid #30363d; border-radius: 12px; 
            background: rgba(22, 27, 34, 0.8); color: #c9d1d9; cursor: pointer; 
            font-size: 0.9rem; font-weight: 600; font-family: 'Inter', sans-serif;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); 
        }
        .btn:hover:not(:disabled) { background: #30363d; transform: translateY(-1px); color: #fff; border-color: #8b949e; }
        .btn:active:not(:disabled) { transform: translateY(0); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .btn.active { background: rgba(88, 166, 255, 0.15); border-color: #58a6ff; color: #58a6ff; }
        
        .progress-bar { width: 100%; height: 3px; background: rgba(48, 54, 61, 0.3); border-radius: 2px; overflow: hidden; margin-top: -12px; margin-bottom: 20px; opacity: 0.8; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #238636, #3fb950, #238636); background-size: 200% 100%; animation: shimmer 2s infinite linear; transition: width 0.3s ease; width: 0%; }
        @keyframes shimmer { 0% { background-position: 100% 0; } 100% { background-position: -100% 0; } }
        
        .stats-row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 24px; }
        .stat-card { 
            background: var(--card-bg); border: 1px solid var(--card-border); 
            border-radius: 16px; padding: 20px; text-align: center; 
            backdrop-filter: blur(10px); transition: transform 0.2s, border-color 0.2s; 
        }
        .stat-card:hover { transform: translateY(-3px); border-color: #58a6ff; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        .stat-card .label { color: #8b949e; font-size: 0.8rem; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
        .stat-card .value { font-size: 1.8rem; font-weight: 800; line-height: 1.2; }
        .stat-card .value.green { color: #3fb950; text-shadow: 0 0 20px rgba(63, 185, 80, 0.2); } 
        .stat-card .value.red { color: #f85149; text-shadow: 0 0 20px rgba(248, 81, 73, 0.2); } 
        .stat-card .value.yellow { color: #d29922; text-shadow: 0 0 20px rgba(210, 153, 34, 0.2); } 
        .stat-card .value.blue { color: #58a6ff; text-shadow: 0 0 20px rgba(88, 166, 255, 0.2); }
        
        .table-container { 
            background: var(--card-bg); border: 1px solid var(--card-border); 
            border-radius: 16px; overflow-x: auto; backdrop-filter: blur(10px); 
            box-shadow: 0 10px 30px rgba(0,0,0,0.1); 
        }
        table { width: 100%; border-collapse: separate; border-spacing: 0; min-width: 900px; }
        th { 
            background: rgba(13, 17, 23, 0.95); padding: 16px 20px; text-align: left; 
            font-weight: 600; color: #8b949e; font-size: 0.8rem; 
            text-transform: uppercase; letter-spacing: 0.5px;
            border-bottom: 1px solid #30363d; white-space: nowrap; 
            position: sticky; top: 0; z-index: 10; backdrop-filter: blur(5px);
        }
        td { padding: 14px 20px; border-bottom: 1px solid rgba(48, 54, 61, 0.4); vertical-align: middle; transition: background 0.1s; }
        tr:last-child td { border-bottom: none; }
        tr:hover td { background: rgba(56, 139, 253, 0.05); }
        
        .text-center { text-align: center; }
        .text-right { text-align: right; }
        
        td.text-center .trend-badge { margin: 0 auto; }
        td.text-center .mini-chart { margin: 0 auto; }
        
        .coin-info { display: flex; align-items: center; gap: 12px; }
        .coin-icon { width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: #1b2230; overflow: hidden; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .coin-icon img { width: 70%; height: 70%; object-fit: contain; display: block; }
        .coin-icon-fallback { width: 100%; height: 100%; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; font-weight: 700; color: #ffffff; background: linear-gradient(135deg, #30363d, #161b22); }
        .coin-name { font-weight: 600; color: #e6edf3; font-size: 0.95rem; font-family: 'Inter', 'Microsoft YaHei', sans-serif; }
        .coin-symbol { color: #8b949e; font-size: 0.8rem; font-weight: 500; }
        .price { font-weight: 600; color: #e6edf3; font-size: 0.95rem; font-variant-numeric: tabular-nums; letter-spacing: 0.5px; }
        
        .btn-star {
            background: transparent;
            border: none;
            cursor: pointer;
            color: #484f58;
            font-size: 1.4rem;
            transition: all 0.2s;
            padding: 0;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .btn-star:hover {
            color: #e6edf3;
            transform: scale(1.2);
        }
        .btn-star.active {
            color: #d29922; /* Gold color */
            text-shadow: 0 0 15px rgba(210, 153, 34, 0.6);
            animation: star-pulse 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes star-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.4); }
            100% { transform: scale(1); }
        }

        .trend-badge { display: flex; flex-direction: column; align-items: center; min-width: 56px; border-radius: 8px; overflow: hidden; transition: transform 0.2s; }
        .trend-badge:hover { transform: scale(1.05); }
        .trend-badge .tf { font-size: 0.65rem; padding: 2px 0; background: rgba(0,0,0,0.2); color: rgba(255,255,255,0.7); width: 100%; text-align: center; font-weight: 600; }
        .trend-badge .signal { font-size: 0.75rem; font-weight: 700; padding: 4px 0; width: 100%; text-align: center; }
        .trend-badge.buy { background: linear-gradient(180deg, rgba(63, 185, 80, 0.1), rgba(63, 185, 80, 0.2)); border: 1px solid rgba(63, 185, 80, 0.3); }
        .trend-badge.buy .signal { color: #3fb950; text-shadow: 0 0 5px rgba(63, 185, 80, 0.3); }
        .trend-badge.sell { background: linear-gradient(180deg, rgba(248, 81, 73, 0.1), rgba(248, 81, 73, 0.2)); border: 1px solid rgba(248, 81, 73, 0.3); }
        .trend-badge.sell .signal { color: #f85149; text-shadow: 0 0 5px rgba(248, 81, 73, 0.3); }
        .trend-badge.neutral { background: rgba(210, 153, 34, 0.1); border: 1px solid rgba(210, 153, 34, 0.2); }
        .trend-badge.neutral .signal { color: #d29922; }
        .trend-badge.loading { background: rgba(88, 166, 255, 0.1); border: 1px solid rgba(88, 166, 255, 0.2); }
        .trend-badge.loading .signal { color: #58a6ff; animation: pulse 1.5s infinite; }
        
        .mini-chart { width: 90px; height: 36px; display: block; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2)); }
        
        .score-badge { display: inline-block; padding: 6px 12px; border-radius: 99px; font-size: 0.8rem; font-weight: 700; border: 1px solid transparent; letter-spacing: 0.5px; }
        .score-strong-buy { color: #3fb950; background: rgba(63,185,80,0.15); border-color: rgba(63,185,80,0.3); box-shadow: 0 0 10px rgba(63,185,80,0.1); }
        .score-buy { color: #2ea043; background: rgba(46,160,67,0.12); border-color: rgba(46,160,67,0.25); }
        .score-neutral { color: #d29922; background: rgba(210,153,34,0.12); border-color: rgba(210,153,34,0.25); }
        .score-sell { color: #f85149; background: rgba(248,81,73,0.12); border-color: rgba(248,81,73,0.25); }
        .score-strong-sell { color: #da3633; background: rgba(218,54,51,0.12); border-color: rgba(218,54,51,0.25); box-shadow: 0 0 10px rgba(218,54,51,0.1); }
        
        .insight-container { 
            display: grid; 
            grid-template-columns: repeat(4, 1fr);
            gap: 1px;
            background: var(--card-border); /* Acts as border for children */
            border: 1px solid var(--card-border);
            border-radius: 16px;
            overflow: hidden;
            margin-bottom: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        .insight-column { 
            background: var(--card-bg); 
            padding: 20px; 
            backdrop-filter: blur(10px); 
            display: flex; flex-direction: column;
            transition: background 0.2s;
        }
        .insight-column:hover { background: rgba(22, 27, 34, 0.9); }
        .insight-title { 
            font-size: 0.95rem; 
            font-weight: 600; 
            color: #e6edf3; 
            margin-bottom: 16px; 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: none;
            padding-bottom: 0;
            font-family: 'Inter', 'Microsoft YaHei', sans-serif;
        }
        .insight-title svg { width: 20px; height: 20px; color: #7d8590; }
        .insight-item { margin-bottom: 8px; font-size: 0.95rem; color: #8b949e; line-height: 1.6; font-family: 'Inter', 'Microsoft YaHei', sans-serif; }
        .insight-item:last-child { margin-bottom: 0; }
        
        .fng-value { font-size: 2.2rem; font-weight: 800; margin-left: 0; display: block; margin-top: 8px; line-height: 1.1; font-family: 'Inter', 'Microsoft YaHei', sans-serif; letter-spacing: -1px; }
        
        .sentiment-bar-bg {
            width: 100%; height: 6px; background: rgba(48, 54, 61, 0.5); border-radius: 3px; margin-top: 12px; overflow: hidden;
            display: flex;
        }
        .sentiment-bar-fill {
            height: 100%; border-radius: 3px; transition: width 1s ease-out;
        }
        
        .insight-section-header {
            font-size: 0.8rem; color: #7d8590; margin-bottom: 4px; font-weight: 500;
        }
        
        .insight-icon-box {
            width: 32px; height: 32px; border-radius: 8px; background: rgba(88, 166, 255, 0.1);
            display: flex; align-items: center; justify-content: center; color: #58a6ff;
            margin-bottom: 4px;
        }

        @media (max-width: 1100px) { 
            .insight-container { grid-template-columns: repeat(2, 1fr); gap: 1px; }
        }
        @media (max-width: 600px) { 
            .insight-container { grid-template-columns: 1fr; }
        }
        .fng-extreme-fear { color: #3fb950; } 
        .fng-fear { color: #a371f7; }
        .fng-neutral { color: #d29922; }
        .fng-greed { color: #f85149; }
        .fng-extreme-greed { color: #da3633; } 
        
        .chart-supertrend-legend {
            position: absolute; top: 12px; right: 70px; z-index: 20;
            font-size: 13px; font-weight: 600; padding: 8px 12px;
            border-radius: 8px; background: rgba(13, 17, 23, 0.9);
            border: 1px solid #30363d; backdrop-filter: blur(4px);
            pointer-events: none; display: flex; align-items: center; gap: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .st-legend-dot { width: 10px; height: 10px; border-radius: 50%; box-shadow: 0 0 8px currentColor; }
        
        /* Skeleton Loading Animation */
        .skeleton { background: linear-gradient(90deg, #161b22 25%, #21262d 50%, #161b22 75%); background-size: 200% 100%; animation: skeleton-loading 1.5s infinite; border-radius: 4px; color: transparent !important; }
        @keyframes skeleton-loading { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
        
        .spinner { width: 40px; height: 40px; border: 4px solid rgba(88, 166, 255, 0.1); border-radius: 50%; border-top-color: #58a6ff; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }

        @media (max-width: 900px) { .stats-row { grid-template-columns: repeat(2, 1fr); } .insight-container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div id="app" v-cloak class="container">
        <!-- 
         * ==================================================================================
         * ã€è§†å›¾å±‚ã€‘å¤´éƒ¨ä¸çŠ¶æ€æ  (Header & Status Bar)
         * ==================================================================================
         * - Header: å±•ç¤ºåº”ç”¨æ ‡é¢˜å’Œ API æ¥æºã€‚
         * - Status Bar: å±•ç¤ºè¿æ¥çŠ¶æ€ã€æœ€åæ›´æ–°æ—¶é—´ï¼Œæä¾›æ‰‹åŠ¨åˆ·æ–°æŒ‰é’®ã€‚
         * - Progress Bar: é¡¶éƒ¨ç»†é•¿è¿›åº¦æ¡ï¼Œç›´è§‚å±•ç¤ºæ•°æ®åŠ è½½è¿›åº¦ã€‚
         * ==================================================================================
         -->
        <header class="header">
            <h1>ğŸš€ Crypto SuperTrend Dashboard</h1>
            <p>å®æ—¶ç›‘æ§å¸‚å€¼å‰250åŠ å¯†è´§å¸çš„å¤šå‘¨æœŸè¶…çº§è¶‹åŠ¿æŒ‡æ ‡ <span class="api-badge">OKX API</span></p>
        </header>

        <div class="status-bar">
            <div class="status-left">
                <div class="status-item">
                    <span :class="['status-dot', loading ? 'loading' : '']"></span>
                    <span>{{ loading ? 'æ­£åœ¨è¿æ¥...' : 'å·²è¿æ¥' }}</span>
                </div>
                <div class="status-item">
                    <span>æœ€åæ›´æ–°ï¼š</span>
                    <span>{{ lastUpdatedFormatted }}</span>
                </div>
            </div>
            <div>
                <button class="btn" @click="fetchData" :disabled="loading">{{ loading ? 'â³ åŠ è½½ä¸­...' : 'ğŸ”„ åˆ·æ–°æ•°æ®' }}</button>
            </div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" :style="{ width: loadPercent + '%' }"></div>
        </div>

        <!-- 
         * ==================================================================================
         * ã€è§†å›¾å±‚ã€‘å¸‚åœºæƒ…ç»ªé¢æ¿ (Market Sentiment Panel)
         * ==================================================================================
         * åŸºäº Alternative.me çš„ææ…Œè´ªå©ªæŒ‡æ•° (FNG)ã€‚
         * åŒ…å«å››ä¸ªæ¿å—ï¼š
         * 1. ä»ªè¡¨ç›˜ï¼šä»Šæ—¥æŒ‡æ•°ã€åˆ†ç±»ã€è¶‹åŠ¿å˜åŒ–åŠè¿›åº¦æ¡ã€‚
         * 2. å¸‚åœºçŠ¶æ€ï¼šåŸºäºæŒ‡æ•°ç”Ÿæˆçš„æ–‡æœ¬åˆ†æã€‚
         * 3. è¡¨ç°é¢„æµ‹ï¼šå¯¹æœªæ¥èµ°åŠ¿çš„ç®€è¦é¢„æµ‹ã€‚
         * 4. æ“ä½œå»ºè®®ï¼šé’ˆå¯¹å½“å‰æƒ…ç»ªçš„æŠ•èµ„å»ºè®®ã€‚
         * ==================================================================================
         -->
        <div v-if="sentiment" class="insight-container">
            <div class="insight-column">
                <div class="insight-title">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" /></svg>
                    å¸‚åœºæƒ…ç»ª
                </div>
                <div class="insight-item" style="margin-top:auto;margin-bottom:auto;">
                    <div class="insight-section-header">
                        ä»Šæ—¥ææ…Œè´ªå©ªæŒ‡æ•° 
                        <span style="font-weight:400;color:#8b949e;font-size:0.8rem;margin-left:4px;opacity:0.8;">{{ sentiment.today.dateStr }}</span>
                    </div>
                    <span :class="['fng-value', getSentimentClass(sentiment.today.value)]">
                        {{ sentiment.today.value }}
                        <span style="font-size:1.2rem;font-weight:600;color:#8b949e;vertical-align:middle;margin-left:4px;">{{ sentiment.today.value_classification }}</span>
                    </span>
                    
                    <div class="sentiment-bar-bg">
                         <div class="sentiment-bar-fill" :style="{width: sentiment.today.value + '%', backgroundColor: getSentimentColor(sentiment.today.value)}"></div>
                    </div>

                    <div style="font-size:0.85rem;color:#8b949e;margin-top:12px;display:flex;justify-content:space-between;">
                        <span>æ˜¨æ—¥ <span style="font-size:0.8rem;opacity:0.8;">{{ sentiment.yesterday.dateStr }}</span>: <span style="color:#e6edf3;font-weight:600;">{{ sentiment.yesterday.value }}</span></span>
                        <span>
                             å˜åŒ–: <span :style="{color: (parseInt(sentiment.today.value) - parseInt(sentiment.yesterday.value)) >= 0 ? '#3fb950' : '#f85149', fontWeight: 600}">{{ parseInt(sentiment.today.value) - parseInt(sentiment.yesterday.value) > 0 ? '+' : ''}}{{ parseInt(sentiment.today.value) - parseInt(sentiment.yesterday.value) }}</span>
                        </span>
                    </div>
                </div>
            </div>

            <div class="insight-column">
                <div class="insight-title">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 013 19.875v-6.75zM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V8.625zM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V4.125z" /></svg>
                    å¸‚åœºçŠ¶æ€
                </div>
                <div class="insight-item" v-for="(line, idx) in sentiment.analysis" :key="'analysis-'+idx">
                    {{ line }}
                </div>
            </div>

            <div class="insight-column">
                <div class="insight-title">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3v11.25A2.25 2.25 0 006 16.5h2.25M3.75 3h-1.5m1.5 0h16.5m0 0h1.5m-1.5 0v11.25A2.25 2.25 0 0118 16.5h-2.25m-7.5 0h7.5m-7.5 0l-1 3m8.5-3l1 3m0 0l.5 1.5m-.5-1.5h-9.5m0 0l-.5 1.5m.75-9l3-3 2.148 2.148A12.061 12.061 0 0116.5 7.605" /></svg>
                    è¡¨ç°é¢„æµ‹
                </div>
                <div class="insight-item" v-for="(line, idx) in sentiment.prediction" :key="'pred-'+idx">
                    {{ line }}
                </div>
            </div>

            <div class="insight-column">
                <div class="insight-title">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 001.5-.189m-1.5.189a6.01 6.01 0 01-1.5-.189m3.75 2.625v-8.196a2.25 2.25 0 011.053-1.948l.972-.584m-4.275 10.728a6.75 6.75 0 01-6.75 6.75v-1.5a5.25 5.25 0 005.25-5.25v-8.196a2.25 2.25 0 011.053-1.948l.972-.584m0 0a2.25 2.25 0 011.053 1.948v.984" /></svg>
                    æ“ä½œå»ºè®®
                </div>
                <div class="insight-item">
                    {{ sentiment.advice }}
                </div>
            </div>
        </div>

        <!-- 
         * ==================================================================================
         * ã€è§†å›¾å±‚ã€‘æ§åˆ¶ä¸ç»Ÿè®¡æ  (Controls & Stats)
         * ==================================================================================
         * - Controls: æœç´¢æ¡†ã€ç­›é€‰æ± å¼€å…³ã€å¤šç»´æ’åºæŒ‰é’®ã€çŠ¶æ€è¿‡æ»¤å™¨ã€‚
         * - Stats Row: å®æ—¶ç»Ÿè®¡å½“å‰çœ‹æ¶¨/çœ‹è·Œ/ä¸­æ€§å¸ç§çš„æ•°é‡ï¼Œè¾…åŠ©åˆ¤æ–­å¤§ç›˜æƒ…ç»ªã€‚
         * ==================================================================================
         -->
        <div class="controls">
            <input v-model="searchQuery" type="text" placeholder="æœç´¢å¸ç§..." class="btn" style="min-width:260px;">
            <button class="btn" :class="{ active: viewMode === 'watchlist' }" @click="toggleViewMode">
                â­ ç­›é€‰æ±  ({{ selectedCoins.size }})
            </button>
            <div style="width: 1px; height: 30px; background: #30363d; margin: 0 8px;"></div>
            <button class="btn" @click="sortBy('rank')">æŒ‰æ’åæ’åº {{ sortKey==='rank' ? (sortOrder==='asc'?'â†‘':'â†“') : '' }}</button>
            <button class="btn" @click="sortBy('price')">æŒ‰ä»·æ ¼æ’åº {{ sortKey==='price' ? (sortOrder==='asc'?'â†‘':'â†“') : '' }}</button>
            <button class="btn" @click="sortBy('changePercent')">æŒ‰æ¶¨è·Œæ’åº {{ sortKey==='changePercent' ? (sortOrder==='asc'?'â†‘':'â†“') : '' }}</button>
            <button class="btn" :class="{ active: filterStatus==='all' }" @click="setFilter('all')">å…¨éƒ¨</button>
            <button class="btn" :class="{ active: filterStatus==='bullish' }" @click="setFilter('bullish')">ğŸŸ¢ çœ‹æ¶¨</button>
            <button class="btn" :class="{ active: filterStatus==='bearish' }" @click="setFilter('bearish')">ğŸ”´ çœ‹è·Œ</button>
            <button class="btn" :class="{ active: filterStatus==='neutral' }" @click="setFilter('neutral')">ğŸŸ¡ ä¸­æ€§</button>
        </div>

        <div class="stats-row">
            <div class="stat-card"><div class="label">çœ‹æ¶¨ä¿¡å·</div><div class="value green">{{ stats.bullish }}</div></div>
            <div class="stat-card"><div class="label">çœ‹è·Œä¿¡å·</div><div class="value red">{{ stats.bearish }}</div></div>
            <div class="stat-card"><div class="label">ä¸­æ€§ä¿¡å·</div><div class="value yellow">{{ stats.neutral }}</div></div>
            <div class="stat-card"><div class="label">å·²åŠ è½½</div><div class="value blue">{{ loadedCount }}/{{ coins.length }}</div></div>
        </div>

        <!-- 
         * ==================================================================================
         * ã€è§†å›¾å±‚ã€‘ä¸»æ•°æ®è¡¨æ ¼ (Main Data Table)
         * ==================================================================================
         * æ ¸å¿ƒå±•ç¤ºåŒºåŸŸï¼Œåˆ—å‡ºæ‰€æœ‰ç›‘æ§å¸ç§ã€‚
         * ç‰¹æ€§ï¼š
         * - å“åº”å¼åˆ—å®½ã€‚
         * - éª¨æ¶å±åŠ è½½ (Skeleton Loading) æå‡ç”¨æˆ·ä½“éªŒã€‚
         * - è¿·ä½ è¶‹åŠ¿å›¾ (Sparkline) é¢„è§ˆèµ°åŠ¿ã€‚
         * - å¤šå‘¨æœŸè¶‹åŠ¿å¾½ç«  (TrendBadge)ã€‚
         * ==================================================================================
         -->
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th class="text-center">#</th>
                        <th class="text-center" style="width: 50px;">é€‰</th>
                        <th>å¸ç§</th>
                        <th class="text-right">ä»·æ ¼</th>
                        <th class="text-right">ä»Šæ—¥æ¶¨è·Œ</th>
                        <th class="text-center">15åˆ†é’Ÿ</th>
                        <th class="text-center">1å°æ—¶</th>
                        <th class="text-center">4å°æ—¶</th>
                        <th class="text-center">æ—¥çº¿</th>
                        <th class="text-center">å‘¨çº¿</th>
                        <th class="text-center">ç»¼åˆè¯„åˆ†</th>
                        <th class="text-center">è¶‹åŠ¿å›¾</th>
                    </tr>
                </thead>
                <tbody>
                    <tr v-if="loading && coins.length === 0" v-for="i in 10" :key="'skeleton-'+i">
                        <td class="text-center"><div class="skeleton" style="width: 20px; height: 16px; margin: 0 auto;"></div></td>
                        <td class="text-center"><div class="skeleton" style="width: 20px; height: 20px; margin: 0 auto; border-radius: 50%;"></div></td>
                        <td>
                            <div class="coin-info">
                                <div class="coin-icon skeleton"></div>
                                <div>
                                    <div class="skeleton" style="width: 60px; height: 14px; margin-bottom: 4px;"></div>
                                    <div class="skeleton" style="width: 40px; height: 12px;"></div>
                                </div>
                            </div>
                        </td>
                        <td class="text-right"><div class="skeleton" style="width: 80px; height: 20px; margin-left: auto;"></div></td>
                        <td class="text-right"><div class="skeleton" style="width: 60px; height: 20px; margin-left: auto;"></div></td>
                        <td class="text-center"><div class="trend-badge skeleton" style="border:none; height: 32px; margin: 0 auto;"></div></td>
                        <td class="text-center"><div class="trend-badge skeleton" style="border:none; height: 32px; margin: 0 auto;"></div></td>
                        <td class="text-center"><div class="trend-badge skeleton" style="border:none; height: 32px; margin: 0 auto;"></div></td>
                        <td class="text-center"><div class="trend-badge skeleton" style="border:none; height: 32px; margin: 0 auto;"></div></td>
                        <td class="text-center"><div class="trend-badge skeleton" style="border:none; height: 32px; margin: 0 auto;"></div></td>
                        <td class="text-center"><div class="score-badge skeleton" style="width: 60px; height: 24px; border:none; margin: 0 auto;"></div></td>
                        <td class="text-center"><div class="mini-chart skeleton" style="height: 36px; margin: 0 auto;"></div></td>
                    </tr>
                    <tr v-for="coin in filteredCoins" :key="coin.symbol" @click="openChart(coin)" style="cursor: pointer;">
                        <td class="text-center">{{ coin.rank }}</td>
                        <td class="text-center" @click.stop="toggleSelection(coin)">
                            <button class="btn-star" :class="{ active: isSelected(coin) }">
                                â˜…
                            </button>
                        </td>
                        <td>
                            <div class="coin-info">
                                <div class="coin-icon">
                                    <img v-if="coin.image" :src="coin.image" :alt="coin.symbol" @error="coin.image = null">
                                    <div v-else class="coin-icon-fallback" :style="{ background: coinColor(coin.symbol) }">
                                        {{ coin.symbol.slice(0,3) }}
                                    </div>
                                </div>
                                <div>
                                    <div class="coin-name">{{ coin.name }}</div>
                                    <div class="coin-symbol">{{ coin.symbol }}/USDT</div>
                                </div>
                            </div>
                        </td>
                        <td class="text-right"><div class="price">${{ formatPrice(coin.price) }}</div></td>
                        <td class="text-right">
                            <span :style="{ color: coin.changePercent >= 0 ? '#3fb950' : '#f85149', fontWeight: 'bold' }">
                                {{ coin.changePercent >= 0 ? '+' : '' }}{{ coin.changePercent.toFixed(2) }}%
                            </span>
                        </td>
                        <td class="text-center"><trend-badge label="15m" :trend="coin.trend_15m"></trend-badge></td>
                        <td class="text-center"><trend-badge label="1h" :trend="coin.trend_1h"></trend-badge></td>
                        <td class="text-center"><trend-badge label="4h" :trend="coin.trend_4h"></trend-badge></td>
                        <td class="text-center"><trend-badge label="1d" :trend="coin.trend_1d"></trend-badge></td>
                        <td class="text-center"><trend-badge label="1w" :trend="coin.trend_1w"></trend-badge></td>
                        <td class="text-center score-cell"><span :class="['score-badge', scoreInfo(coin).klass]">{{ scoreInfo(coin).label }}</span></td>
                        <td class="text-center" v-html="generateMiniChart(coin)"></td>
                    </tr>
                    <tr v-if="filteredCoins.length === 0">
                        <td colspan="12" style="text-align:center;padding:40px;">
                            <div v-if="viewMode === 'watchlist'" style="display:flex;flex-direction:column;gap:10px;align-items:center;">
                                <span style="font-size:3rem;">â­</span>
                                <span style="font-size:1.2rem;font-weight:600;">ç­›é€‰æ± ä¸ºç©º</span>
                                <span style="color:#8b949e;">è¯·åœ¨åˆ—è¡¨ä¸­ç‚¹å‡»æ˜Ÿå·å›¾æ ‡æ·»åŠ å…³æ³¨å¸ç§</span>
                            </div>
                            <span v-else>æš‚æ— æ•°æ®æˆ–æ­£åœ¨åŠ è½½â€¦</span>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- 
         * ==================================================================================
         * ã€è§†å›¾å±‚ã€‘å›¾è¡¨å¼¹çª— (Chart Modal)
         * ==================================================================================
         * ç‚¹å‡»å¸ç§è¡Œåè§¦å‘ï¼Œå…¨å±è¦†ç›–ã€‚
         * åŒ…å« 5 ä¸ªå‘¨æœŸçš„ Lightweight Charts å®ä¾‹ (15m, 1h, 4h, 1d, 1w)ã€‚
         * ==================================================================================
         -->
        <!-- Chart Modal -->
        <div v-if="showModal" class="modal-overlay" @click.self="closeModal">
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">
                        <div class="coin-icon" style="width: 32px; height: 32px;">
                            <img v-if="activeCoin.image" :src="activeCoin.image" :alt="activeCoin.symbol">
                            <div v-else class="coin-icon-fallback" :style="{ background: coinColor(activeCoin.symbol) }">{{ activeCoin.symbol.slice(0,3) }}</div>
                        </div>
                        {{ activeCoin.symbol }} / USDT å¤šå‘¨æœŸè¶…çº§è¶‹åŠ¿å›¾è¡¨
                    </div>
                    <button class="modal-close" @click="closeModal">Ã—</button>
                </div>
                <div class="modal-body">
                    <div class="chart-container" v-for="tf in timeframes" :key="tf.bar">
                        <div class="chart-header">
                            <span>{{ tf.label }} Chart <span v-if="tf.candleCount" style="font-size:0.75rem;color:#586069;">({{ tf.candleCount }})</span></span>
                            <span v-if="tf.trend" :style="{ color: tf.trend === 'UP' ? '#3fb950' : '#f85149' }">
                                Supertrend: {{ tf.trend }}
                            </span>
                        </div>
                        <div :id="'chart-' + tf.bar" class="chart-wrapper"></div>
                        <div v-if="tf.loading" class="loading-overlay">
                            <div class="spinner"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================================================================================
        // ã€åº”ç”¨æ¶æ„ã€‘å•é¡µåº”ç”¨ (Single Page Application, SPA)
        // ==================================================================================
        // æŠ€æœ¯æ ˆï¼š
        // 1. Vue 3 (Composition API)ï¼šè´Ÿè´£æ ¸å¿ƒçŠ¶æ€ç®¡ç†ã€å“åº”å¼æ•°æ®ç»‘å®šå’Œç»„ä»¶åŒ–å¼€å‘ã€‚
        //    - ä½¿ç”¨ createApp().mount() æŒ‚è½½åº”ç”¨ã€‚
        //    - å¤§é‡ä½¿ç”¨ computed å±æ€§è¿›è¡Œé«˜æ•ˆçš„æ•°æ®æ´¾ç”Ÿï¼ˆå¦‚è¿‡æ»¤ã€æ’åºã€ç»Ÿè®¡ï¼‰ã€‚
        // 2. Lightweight Chartsï¼šè´Ÿè´£é«˜æ€§èƒ½ K çº¿å›¾è¡¨æ¸²æŸ“ã€‚
        // 3. åŸç”Ÿ Fetch APIï¼šè´Ÿè´£ä¸å¤–éƒ¨æ•°æ®æºï¼ˆOKX, Alternative.meï¼‰è¿›è¡Œå¼‚æ­¥é€šä¿¡ã€‚
        //
        // ä¸ºä»€ä¹ˆé€‰æ‹©æ­¤æ¶æ„ï¼š
        // - è½»é‡çº§ï¼šæ— éœ€æ„å»ºå·¥å…·ï¼ˆCDN å¼•å…¥ï¼‰ï¼Œç›´æ¥è¿è¡Œï¼Œé€‚åˆå•æ–‡ä»¶å¿«é€Ÿå¼€å‘å’Œéƒ¨ç½²ã€‚
        // - å“åº”å¼ï¼šVue 3 çš„å“åº”å¼ç³»ç»Ÿèƒ½è‡ªåŠ¨å¤„ç†å¤æ‚çš„æ•°æ®æ›´æ–°ï¼ˆ250ä¸ªå¸ç§ * 5ä¸ªå‘¨æœŸï¼‰ã€‚
        // ==================================================================================
        const { createApp, ref, computed, onMounted } = Vue;

        // ==================================================================================
        // ã€ç»„ä»¶å±‚ã€‘UI ç»„ä»¶å®šä¹‰
        // ==================================================================================
        // å®šä¹‰å¯å¤ç”¨çš„ UI å•å…ƒã€‚
        // TrendBadge: å±•ç¤º "15m UP" æˆ– "4h DOWN" ç­‰è¶‹åŠ¿çŠ¶æ€ï¼ŒåŒ…å«é¢œè‰²é€»è¾‘å’Œ Loading éª¨æ¶å±ã€‚
        // ==================================================================================
        const TrendBadge = {
            props: ['trend','label'],
            template: `
                <div v-if="trend === 'Loading'" class="trend-badge skeleton" style="border:none;">
                    <div class="tf" style="visibility:hidden;">{{ label }}</div>
                    <div class="signal" style="visibility:hidden;">...</div>
                </div>
                <div v-else :class="klass" class="trend-badge">
                    <div class="tf">{{ label }}</div>
                    <div class="signal">{{ text }}</div>
                </div>
            `,
            computed: {
                klass() {
                    if (this.trend === 'UP' ) return 'buy';
                    if (this.trend === 'DOWN') return 'sell';
                    if (this.trend === 'Loading') return 'loading';
                    return 'neutral';
                },
                text() {
                    if (this.trend === 'UP') return 'BUY';
                    if (this.trend === 'DOWN') return 'SELL';
                    if (this.trend === 'Loading') return '...';
                    if (this.trend === 'Error') return 'Error';
                    return 'N/A';
                }
            }
        };

        // ==================================================================================
        // ã€é‡åŒ–å¼•æ“ã€‘æ ¸å¿ƒæŒ‡æ ‡è®¡ç®—æ¨¡å— (Quantitative Engine)
        // ==================================================================================
        // æœ¬æ¨¡å—åŒ…å«æ‰€æœ‰æŠ€æœ¯åˆ†ææŒ‡æ ‡çš„çº¯æ•°å­¦å®ç°ã€‚
        // è¾“å…¥ï¼šOHLC åŸå§‹æ•°æ®æ•°ç»„ã€‚
        // è¾“å‡ºï¼šè®¡ç®—åçš„æŒ‡æ ‡å€¼æˆ–è¶‹åŠ¿ä¿¡å·ã€‚
        //
        // æ ¸å¿ƒç®—æ³•ï¼šSupertrend (è¶…çº§è¶‹åŠ¿)
        // åŸç†ï¼šåŸºäº ATR (å¹³å‡çœŸå®æ³¢å¹…) è®¡ç®—ä¸Šä¸‹è½¨ã€‚
        //      - å½“ä»·æ ¼çªç ´ä¸Šè½¨æ—¶ï¼Œè¶‹åŠ¿è½¬ä¸ºä¸‹è·Œï¼ˆçº¢ï¼‰ã€‚
        //      - å½“ä»·æ ¼çªç ´ä¸‹è½¨æ—¶ï¼Œè¶‹åŠ¿è½¬ä¸ºä¸Šæ¶¨ï¼ˆç»¿ï¼‰ã€‚
        // ==================================================================================

        function calculateSupertrend(ohlc, period = 10, multiplier = 3) {
            if (ohlc.length < period + 1) return 'N/A';

            const high = ohlc.map(c => c.high);
            const low = ohlc.map(c => c.low);
            const close = ohlc.map(c => c.close);

            const tr = [];
            for (let i = 0; i < ohlc.length; i++) {
                if (i === 0) {
                    tr.push(high[i] - low[i]);
                } else {
                    const tr1 = high[i] - low[i];
                    const tr2 = Math.abs(high[i] - close[i - 1]);
                    const tr3 = Math.abs(low[i] - close[i - 1]);
                    tr.push(Math.max(tr1, tr2, tr3));
                }
            }

            const atr = [];
            let prevAtr = tr[0];
            atr.push(prevAtr);
            const alpha = 1 / period;
            for (let i = 1; i < tr.length; i++) {
                const curAtr = alpha * tr[i] + (1 - alpha) * prevAtr;
                atr.push(curAtr);
                prevAtr = curAtr;
            }

            const basicUpper = [];
            const basicLower = [];
            for (let i = 0; i < ohlc.length; i++) {
                const hl2 = (high[i] + low[i]) / 2;
                basicUpper.push(hl2 + multiplier * atr[i]);
                basicLower.push(hl2 - multiplier * atr[i]);
            }

            const finalUpper = [];
            const finalLower = [];
            const supertrend = [];
            const trend = [];

            finalUpper[0] = basicUpper[0];
            finalLower[0] = basicLower[0];
            supertrend[0] = finalLower[0];
            trend[0] = true;

            for (let i = 1; i < ohlc.length; i++) {
                if (basicUpper[i] < finalUpper[i - 1] || close[i - 1] > finalUpper[i - 1]) {
                    finalUpper[i] = basicUpper[i];
                } else {
                    finalUpper[i] = finalUpper[i - 1];
                }

                if (basicLower[i] > finalLower[i - 1] || close[i - 1] < finalLower[i - 1]) {
                    finalLower[i] = basicLower[i];
                } else {
                    finalLower[i] = finalLower[i - 1];
                }

                if (supertrend[i - 1] === finalUpper[i - 1] && close[i] <= finalUpper[i]) {
                    trend[i] = false;
                    supertrend[i] = finalUpper[i];
                } else if (supertrend[i - 1] === finalUpper[i - 1] && close[i] > finalUpper[i]) {
                    trend[i] = true;
                    supertrend[i] = finalLower[i];
                } else if (supertrend[i - 1] === finalLower[i - 1] && close[i] >= finalLower[i]) {
                    trend[i] = true;
                    supertrend[i] = finalLower[i];
                } else if (supertrend[i - 1] === finalLower[i - 1] && close[i] < finalLower[i]) {
                    trend[i] = false;
                    supertrend[i] = finalUpper[i];
                } else {
                    if (close[i] > finalUpper[i - 1]) {
                        trend[i] = true;
                    } else if (close[i] < finalLower[i - 1]) {
                        trend[i] = false;
                    } else {
                        trend[i] = trend[i - 1];
                    }
                    supertrend[i] = trend[i] ? finalLower[i] : finalUpper[i];
                }
            }

            return trend[trend.length - 1] ? 'UP' : 'DOWN';
        }

        // ==================================================================================
        // ã€æ•°æ®è®¿é—®å±‚ã€‘å¤–éƒ¨ API é›†æˆ (Data Access Layer)
        // ==================================================================================
        // è´Ÿè´£æ‰€æœ‰ä¸å¤–éƒ¨äº¤æ˜“æ‰€æˆ–æ•°æ®æä¾›å•†çš„é€šä¿¡ã€‚
        // ç‰¹æ€§ï¼š
        // 1. é”™è¯¯å¤„ç†ï¼šç»Ÿä¸€æ•è· HTTP é”™è¯¯å’Œä¸šåŠ¡é€»è¾‘é”™è¯¯ã€‚
        // 2. æ•°æ®æ¸…æ´—ï¼šå°†åŸå§‹ API å“åº”æ ¼å¼åŒ–ä¸ºåº”ç”¨å†…éƒ¨ä½¿ç”¨çš„æ ‡å‡† OHLC å¯¹è±¡ã€‚
        // ==================================================================================

        async function fetchOkxTickers() {
            const url = 'https://www.okx.com/api/v5/market/tickers?instType=SPOT';
            const res = await fetch(url);
            const json = await res.json();
            if (json.code !== '0') throw new Error('OKX tickers error: ' + JSON.stringify(json));
            return json.data;
        }

        async function fetchOkxCandles(instId, bar, limit = 100) {
            const url = `https://www.okx.com/api/v5/market/candles?instId=${encodeURIComponent(instId)}&bar=${encodeURIComponent(bar)}&limit=${limit}`;
            const res = await fetch(url);
            if (!res.ok) throw new Error('HTTP ' + res.status);
            const json = await res.json();
            if (json.code !== '0') throw new Error('OKX candles error: ' + JSON.stringify(json));
            const candles = json.data || [];
            if (!candles.length) return null;

            const ohlc = candles.map(c => ({
                ts: Number(c[0]),
                open: Number(c[1]),
                high: Number(c[2]),
                low: Number(c[3]),
                close: Number(c[4])
            })).sort((a, b) => a.ts - b.ts);

            return ohlc;
        }

        function calculateSupertrendFull(ohlc, period = 10, multiplier = 3) {
            if (!ohlc || ohlc.length < period + 1) return null;

            const high = ohlc.map(c => c.high);
            const low = ohlc.map(c => c.low);
            const close = ohlc.map(c => c.close);

            const tr = [];
            for (let i = 0; i < ohlc.length; i++) {
                if (i === 0) {
                    tr.push(high[i] - low[i]);
                } else {
                    const tr1 = high[i] - low[i];
                    const tr2 = Math.abs(high[i] - close[i - 1]);
                    const tr3 = Math.abs(low[i] - close[i - 1]);
                    tr.push(Math.max(tr1, tr2, tr3));
                }
            }

            const atr = [];
            let prevAtr = tr[0];
            atr.push(prevAtr);
            const alpha = 1 / period;
            for (let i = 1; i < tr.length; i++) {
                const curAtr = alpha * tr[i] + (1 - alpha) * prevAtr;
                atr.push(curAtr);
                prevAtr = curAtr;
            }

            const basicUpper = [];
            const basicLower = [];
            for (let i = 0; i < ohlc.length; i++) {
                const hl2 = (high[i] + low[i]) / 2;
                basicUpper.push(hl2 + multiplier * atr[i]);
                basicLower.push(hl2 - multiplier * atr[i]);
            }

            const finalUpper = [];
            const finalLower = [];
            const supertrend = [];
            const trend = []; // true for UP, false for DOWN

            finalUpper[0] = basicUpper[0];
            finalLower[0] = basicLower[0];
            supertrend[0] = finalLower[0];
            trend[0] = true;

            for (let i = 1; i < ohlc.length; i++) {
                if (basicUpper[i] < finalUpper[i - 1] || close[i - 1] > finalUpper[i - 1]) {
                    finalUpper[i] = basicUpper[i];
                } else {
                    finalUpper[i] = finalUpper[i - 1];
                }

                if (basicLower[i] > finalLower[i - 1] || close[i - 1] < finalLower[i - 1]) {
                    finalLower[i] = basicLower[i];
                } else {
                    finalLower[i] = finalLower[i - 1];
                }

                if (supertrend[i - 1] === finalUpper[i - 1] && close[i] <= finalUpper[i]) {
                    trend[i] = false;
                    supertrend[i] = finalUpper[i];
                } else if (supertrend[i - 1] === finalUpper[i - 1] && close[i] > finalUpper[i]) {
                    trend[i] = true;
                    supertrend[i] = finalLower[i];
                } else if (supertrend[i - 1] === finalLower[i - 1] && close[i] >= finalLower[i]) {
                    trend[i] = true;
                    supertrend[i] = finalLower[i];
                } else if (supertrend[i - 1] === finalLower[i - 1] && close[i] < finalLower[i]) {
                    trend[i] = false;
                    supertrend[i] = finalUpper[i];
                } else {
                    // Fallback logic
                    if (close[i] > finalUpper[i - 1]) {
                        trend[i] = true;
                    } else if (close[i] < finalLower[i - 1]) {
                        trend[i] = false;
                    } else {
                        trend[i] = trend[i - 1];
                    }
                    supertrend[i] = trend[i] ? finalLower[i] : finalUpper[i];
                }
            }

            return {
                direction: trend[trend.length - 1] ? 'UP' : 'DOWN',
                supertrendSeries: ohlc.map((c, i) => ({
                    time: Math.floor(c.ts / 1000) + 28800, // UTC+8 (Beijing Time)
                    value: supertrend[i],
                    color: trend[i] ? '#22c55e' : '#ef4444'
                })),
                candles: ohlc.map(c => ({
                    time: Math.floor(c.ts / 1000) + 28800, // UTC+8 (Beijing Time)
                    open: c.open,
                    high: c.high,
                    low: c.low,
                    close: c.close
                }))
            };
        }

        // ==================================================================================
        // ã€ç®—æ³•æ¨¡å—ã€‘ç›¸å¯¹å¼ºå¼±æŒ‡æ•° (RSI) è®¡ç®—
        // ==================================================================================
        // è¡¡é‡ä»·æ ¼å˜åŠ¨çš„é€Ÿåº¦å’Œå˜åŒ–ï¼Œç”¨äºè¯†åˆ«è¶…ä¹°æˆ–è¶…å–çŠ¶æ€ã€‚
        // æ ‡å‡†å‘¨æœŸï¼š14
        // é˜ˆå€¼é€šå¸¸è®¾ä¸ºï¼š70 (è¶…ä¹°), 30 (è¶…å–)
        // ==================================================================================
        function calculateRSI(ohlc, period = 14) {
            if (!ohlc || ohlc.length < period + 1) return [];
            
            const closes = ohlc.map(c => c.close);
            const rsi = [];
            
            // Calculate initial average gain/loss
            let gainSum = 0;
            let lossSum = 0;
            
            for (let i = 1; i <= period; i++) {
                const change = closes[i] - closes[i - 1];
                if (change >= 0) gainSum += change;
                else lossSum += Math.abs(change);
            }
            
            let avgGain = gainSum / period;
            let avgLoss = lossSum / period;
            
            // First RSI
            let rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            rsi[period] = 100 - (100 / (1 + rs));
            
            // Subsequent RSIs
            for (let i = period + 1; i < closes.length; i++) {
                const change = closes[i] - closes[i - 1];
                const currentGain = change > 0 ? change : 0;
                const currentLoss = change < 0 ? Math.abs(change) : 0;
                
                avgGain = (avgGain * (period - 1) + currentGain) / period;
                avgLoss = (avgLoss * (period - 1) + currentLoss) / period;
                
                rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                rsi[i] = 100 - (100 / (1 + rs));
            }
            
            // Map back to time
            return ohlc.map((c, i) => {
                if (i < period) return null;
                return {
                    time: Math.floor(c.ts / 1000) + 28800, // UTC+8
                    value: rsi[i]
                };
            }).filter(item => item !== null);
        }

        createApp({
            components: { TrendBadge },
            setup() {
                // ==================================================================================
                // ã€çŠ¶æ€ç®¡ç†ã€‘å“åº”å¼æ•°æ®ä¸­å¿ƒ (Reactive State Management)
                // ==================================================================================
                // ä½¿ç”¨ Vue 3 ref() å®šä¹‰å•ä¸€æ•°æ®æº (Single Source of Truth)ã€‚
                // - coins: å­˜å‚¨ 250+ å¸ç§çš„å…¨é‡æ•°æ®ï¼ˆä»·æ ¼ã€æ¶¨è·Œå¹…ã€å„å‘¨æœŸè¶‹åŠ¿çŠ¶æ€ï¼‰ã€‚
                // - loading/lastUpdated: å…¨å±€ UI çŠ¶æ€ã€‚
                // - searchQuery/filterStatus: ç­›é€‰æ¡ä»¶çŠ¶æ€ã€‚
                // ==================================================================================
                const coins = ref([]);
                const loading = ref(false);
                const lastUpdated = ref(null);
                const searchQuery = ref('');
                const sortKey = ref('rank');
                const sortOrder = ref('asc');
                const filterStatus = ref('all');
                const selectedCoins = ref(new Set());
                const viewMode = ref('all');

                const loadSelection = () => {
                    const saved = localStorage.getItem('selectedCoins');
                    if (saved) {
                        try {
                            selectedCoins.value = new Set(JSON.parse(saved));
                        } catch (e) {
                            console.error('Failed to load selection', e);
                        }
                    }
                };

                const saveSelection = () => {
                    localStorage.setItem('selectedCoins', JSON.stringify([...selectedCoins.value]));
                };

                const toggleSelection = (coin) => {
                    const newSet = new Set(selectedCoins.value);
                    if (newSet.has(coin.symbol)) {
                        newSet.delete(coin.symbol);
                    } else {
                        newSet.add(coin.symbol);
                    }
                    selectedCoins.value = newSet;
                    saveSelection();
                };

                const isSelected = (coin) => selectedCoins.value.has(coin.symbol);

                const toggleViewMode = () => {
                    viewMode.value = viewMode.value === 'all' ? 'watchlist' : 'all';
                };

                const formatPrice = (price) => {
                    if (price == null || isNaN(price)) return '-';
                    if (price < 1) return price.toFixed(6);
                    if (price < 10) return price.toFixed(4);
                    return price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                };

                const lastUpdatedFormatted = computed(() => {
                    if (!lastUpdated.value) return 'ä»æœª';
                    return new Date(lastUpdated.value).toLocaleString('zh-CN');
                });

                // ==================================================================================
                // ã€è®¡ç®—å±æ€§ã€‘æ•°æ®è¿‡æ»¤ä¸æ’åºç®¡é“ (Filter & Sort Pipeline)
                // ==================================================================================
                // å®ç°é«˜æ•ˆçš„å‰ç«¯æ•°æ®å¤„ç†ï¼š
                // 1. æœç´¢è¿‡æ»¤ï¼šåŒ¹é…åç§°æˆ–ç¬¦å·ã€‚
                // 2. å…³æ³¨è¿‡æ»¤ï¼šä»…æ˜¾ç¤ºæ˜Ÿæ ‡å¸ç§ã€‚
                // 3. çŠ¶æ€è¿‡æ»¤ï¼šç­›é€‰çœ‹æ¶¨/çœ‹è·Œ/ä¸­æ€§å¸ç§ã€‚
                // 4. å¤šç»´æ’åºï¼šæ”¯æŒæŒ‰æ’åã€ä»·æ ¼ã€æ¶¨è·Œå¹…æ’åºã€‚
                // ==================================================================================
                const filteredCoins = computed(() => {
                    let result = coins.value.slice();

                    if (searchQuery.value) {
                        const q = searchQuery.value.toLowerCase();
                        result = result.filter(c =>
                            c.name.toLowerCase().includes(q) ||
                            c.symbol.toLowerCase().includes(q)
                        );
                    }

                    if (viewMode.value === 'watchlist') {
                        result = result.filter(c => selectedCoins.value.has(c.symbol));
                    }

                    if (filterStatus.value !== 'all') {
                        result = result.filter(c => {
                            const arr = [c.trend_15m, c.trend_1h, c.trend_4h, c.trend_1d];
                            const buys = arr.filter(x => x === 'UP').length;
                            const sells = arr.filter(x => x === 'DOWN').length;
                            const category = buys > sells ? 'bullish' : sells > buys ? 'bearish' : 'neutral';
                            return category === filterStatus.value;
                        });
                    }

                    result.sort((a, b) => {
                        let valA = a[sortKey.value];
                        let valB = b[sortKey.value];

                        if (typeof valA === 'string') valA = valA.toLowerCase();
                        if (typeof valB === 'string') valB = valB.toLowerCase();

                        if (valA < valB) return sortOrder.value === 'asc' ? -1 : 1;
                        if (valA > valB) return sortOrder.value === 'asc' ? 1 : -1;
                        return 0;
                    });

                    return result;
                });

                const setFilter = (status) => {
                    filterStatus.value = status;
                };

                const sortBy = (key) => {
                    if (sortKey.value === key) {
                        sortOrder.value = sortOrder.value === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortKey.value = key;
                        sortOrder.value = 'asc';
                    }
                };

                const loadedCount = computed(() => {
                    return coins.value.filter(c => !['Loading'].includes(c.trend_15m) && !['Loading'].includes(c.trend_1h) && !['Loading'].includes(c.trend_4h) && !['Loading'].includes(c.trend_1d)).length;
                });

                const loadPercent = computed(() => {
                    if (!coins.value.length) return 0;
                    return Math.round((loadedCount.value / coins.value.length) * 100);
                });

                const stats = computed(() => {
                    let bullish = 0, bearish = 0, neutral = 0;
                    coins.value.forEach(c => {
                        const arr = [c.trend_15m, c.trend_1h, c.trend_4h, c.trend_1d];
                        const buys = arr.filter(x => x === 'UP').length;
                        const sells = arr.filter(x => x === 'DOWN').length;
                        if (buys > sells) bullish++;
                        else if (sells > buys) bearish++;
                        else neutral++;
                    });
                    return { bullish, bearish, neutral };
                });

                function scoreInfo(coin) {
                    const arr = [coin.trend_15m, coin.trend_1h, coin.trend_4h, coin.trend_1d, coin.trend_1w];
                    const buys = arr.filter(x => x === 'UP').length;
                    const sells = arr.filter(x => x === 'DOWN').length;
                    const diff = buys - sells;
                    if (diff >= 2) return { label: 'å¼ºçœ‹æ¶¨', klass: 'score-strong-buy' };
                    if (diff === 1) return { label: 'çœ‹æ¶¨', klass: 'score-buy' };
                    if (diff === 0) return { label: 'ä¸­æ€§', klass: 'score-neutral' };
                    if (diff === -1) return { label: 'çœ‹è·Œ', klass: 'score-sell' };
                    return { label: 'å¼ºçœ‹è·Œ', klass: 'score-strong-sell' };
                }

                function generateMiniChart(coin) {
                    if (!coin) return '<div class="mini-chart skeleton"></div>';
                    if (!coin.sparkline || coin.sparkline.length < 2) return '<div class="mini-chart skeleton"></div>';
                    
                    const values = coin.sparkline;
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    const range = max - min || 1;
                    
                    const width = 120;
                    const height = 40;
                    const padding = 2;
                    
                    // åæ ‡è®¡ç®—
                    const points = values.map((v, i) => {
                        const x = (i / (values.length - 1)) * width;
                        const y = height - padding - ((v - min) / range) * (height - 2 * padding);
                        return `${x},${y}`;
                    }).join(' ');

                    const isUp = values[values.length - 1] >= values[0];
                    const strokeColor = isUp ? '#22c55e' : '#ef4444';
                    const fillColor = isUp ? '#22c55e' : '#ef4444';
                    
                    // æ¸å˜å¡«å……è·¯å¾„ (é—­åˆåˆ°åº•éƒ¨)
                    // points format: "x1,y1 x2,y2 ..."
                    // We need to ensure the path syntax is robust
                    const firstPoint = points.split(' ')[0];
                    const fillPath = `M0,${height} L${firstPoint} ${points} L${width},${height} Z`;

                    return `
                        <svg class="mini-chart" viewBox="0 0 ${width} ${height}" preserveAspectRatio="none">
                            <defs>
                                <linearGradient id="grad-${coin.symbol}" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" stop-color="${fillColor}" stop-opacity="0.3"/>
                                    <stop offset="100%" stop-color="${fillColor}" stop-opacity="0.0"/>
                                </linearGradient>
                            </defs>
                            <path d="${fillPath}" fill="url(#grad-${coin.symbol})" stroke="none" />
                            <polyline points="${points}" fill="none" stroke="${strokeColor}" stroke-width="2" stroke-linejoin="round" stroke-linecap="round"/>
                        </svg>
                    `;
                }

                function coinIconUrl(symbol) {
                    if (!symbol) return '';
                    return `https://assets.coincap.io/assets/icons/${symbol.toLowerCase()}@2x.png`;
                }

                function coinColor(symbol) {
                    const colors = { BTC:'#F7931A', ETH:'#627EEA', BNB:'#F3BA2F', XRP:'#23292F', SOL:'#00FFA3' };
                    if (colors[symbol]) return colors[symbol];
                    let hash = 0;
                    for (let i=0;i<symbol.length;i++) hash = symbol.charCodeAt(i) + ((hash<<5) - hash);
                    const hue = Math.abs(hash) % 360;
                    return `hsl(${hue}, 60%, 50%)`;
                }

                const showModal = ref(false);
                const activeCoin = ref({});
                const sentiment = ref(null);
                const timeframes = ref([
                    { bar: '15m', label: '15M', loading: false, trend: '', candleCount: 0 },
                    { bar: '1H', label: '1H', loading: false, trend: '', candleCount: 0 },
                    { bar: '4H', label: '4H', loading: false, trend: '', candleCount: 0 },
                    { bar: '1D', label: '1D', loading: false, trend: '', candleCount: 0 },
                    { bar: '1W', label: '1W', loading: false, trend: '', candleCount: 0 }
                ]);
                const chartInstances = {};

                // ==================================================================================
                // ã€ä¸šåŠ¡é€»è¾‘ã€‘å¸‚åœºæƒ…ç»ªæ•°æ®è·å– (Sentiment Data Fetching)
                // ==================================================================================
                // æ•°æ®æºï¼šAlternative.me Crypto Fear & Greed Index
                // åŠŸèƒ½ï¼š
                // 1. è·å–ä»Šæ—¥å’Œæ˜¨æ—¥çš„ææ…Œè´ªå©ªæŒ‡æ•°ã€‚
                // 2. æ ¹æ®æ•°å€¼ç”Ÿæˆå¯¹åº”çš„å¸‚åœºåˆ†ææ–‡æ¡ˆã€é¢„æµ‹å’Œå»ºè®®ã€‚
                // 3. é”™è¯¯å¤„ç†ï¼šåŒ…å«é»˜è®¤å›é€€æ•°æ®ï¼Œç¡®ä¿ UI ä¸å´©æºƒã€‚
                // ==================================================================================
                const fetchSentiment = async () => {
                    try {
                        const res = await fetch('https://api.alternative.me/fng/?limit=2');
                        const json = await res.json();
                        if (json.data && json.data.length >= 2) {
                            const today = json.data[0];
                            const yesterday = json.data[1];
                            
                            // Format Dates
                            const formatDate = (ts) => {
                                const date = new Date(ts * 1000);
                                return `${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥`;
                            };
                            today.dateStr = formatDate(today.timestamp);
                            yesterday.dateStr = formatDate(yesterday.timestamp);

                            const val = parseInt(today.value);
                            
                            // Generate analysis based on value
                            let analysis = [];
                            let prediction = [];
                            let advice = "";

                            if (val <= 25) { // Extreme Fear
                                analysis = ["å¸‚åœºå¤„äºæåº¦ææƒ§çŠ¶æ€ï¼Œææ…Œç›˜æ¶Œå‡º", "é£é™©åå¥½æä½ï¼Œå¤§éƒ¨åˆ†æŠ•èµ„è€…é€‰æ‹©è§‚æœ›"];
                                prediction = ["çŸ­æœŸå¯èƒ½ç»§ç»­ä¸‹æ¢å¯»æ‰¾åº•éƒ¨æ”¯æ’‘", "ä½†ä¹Ÿå¯èƒ½è¿æ¥è¶…è·Œåå¼¹çš„æœºä¼š"];
                                advice = "åˆ«äººææƒ§æˆ‘è´ªå©ªï¼Œå¯è€ƒè™‘åœ¨å…³é”®æ”¯æ’‘ä½åˆ†æ‰¹å»ºä»“ä¼˜è´¨èµ„äº§ï¼Œåˆ‡å‹¿è¿½æ¶¨æ€è·Œã€‚";
                            } else if (val <= 45) { // Fear
                                analysis = ["å¸‚åœºæƒ…ç»ªåå‘è°¨æ…ï¼Œå¤šç©ºåšå¼ˆæ¿€çƒˆ", "å°šæœªå½¢æˆæ˜ç¡®çš„ä¸Šæ¶¨åˆåŠ›"];
                                prediction = ["é¢„è®¡å¸‚åœºå°†åœ¨éœ‡è¡ä¸­å¯»æ‰¾æ–¹å‘", "å…³æ³¨ä¸»åŠ›èµ„é‡‘åŠ¨å‘"];
                                advice = "ä¿æŒè€å¿ƒï¼Œå…³æ³¨åŸºæœ¬é¢è‰¯å¥½çš„å¸ç§ï¼Œå¯é‡‡å–å®šæŠ•ç­–ç•¥å¹³æ‘Šæˆæœ¬ã€‚";
                            } else if (val <= 55) { // Neutral
                                analysis = ["å¤šç©ºåŠ›é‡å‡è¡¡ï¼Œå¸‚åœºç¼ºä¹æ˜ç¡®æŒ‡å¼•", "äº¤æ˜“é‡å¯èƒ½ç›¸å¯¹å¹³æ·¡"];
                                prediction = ["æ¨ªç›˜æ•´ç†æ¦‚ç‡è¾ƒå¤§", "ç­‰å¾…çªç ´ä¿¡å·å‡ºç°"];
                                advice = "è§‚æœ›ä¸ºä¸»ï¼Œå‡å°‘æ“ä½œé¢‘ç‡ï¼Œç­‰å¾…è¶‹åŠ¿æ˜æœ—åå†å…¥åœºã€‚";
                            } else if (val <= 75) { // Greed
                                analysis = ["å¸‚åœºæƒ…ç»ªå›æš–ï¼Œä¹°ç›˜é€æ¸å¢å¼º", "èµšé’±æ•ˆåº”æ˜¾ç°ï¼Œå¸å¼•åœºå¤–èµ„é‡‘å…¥åœº"];
                                prediction = ["çŸ­æœŸè¶‹åŠ¿å‘ä¸Šï¼Œä½†éœ€è­¦æƒ•è·åˆ©ç›˜å›å", "æ¿å—è½®åŠ¨å¯èƒ½åŠ å¿«"];
                                advice = "é¡ºåŠ¿è€Œä¸ºï¼ŒæŒæœ‰æ ¸å¿ƒä»“ä½ï¼Œå¯é€‚å½“å‚ä¸çƒ­ç‚¹æ¿å—ç‚’ä½œï¼Œè®¾ç½®å¥½æ­¢ç›ˆä½ã€‚";
                            } else { // Extreme Greed
                                analysis = ["å¸‚åœºå¤„äºæåº¦è´ªå©ªçŠ¶æ€ï¼ŒFOMOæƒ…ç»ªé«˜æ¶¨", "é£é™©ç´¯ç§¯è¾ƒé«˜ï¼Œéšæ—¶å¯èƒ½å‡ºç°å›è°ƒ"];
                                prediction = ["åŠ é€Ÿå†²é¡¶åå¯èƒ½å‡ºç°å‰§çƒˆæ³¢åŠ¨", "è°¨é˜²ä¸»åŠ›é«˜ä½å‡ºè´§"];
                                advice = "åˆ«äººè´ªå©ªæˆ‘ææƒ§ï¼Œå»ºè®®åˆ†æ‰¹æ­¢ç›ˆï¼Œé™ä½ä»“ä½ï¼Œè½è¢‹ä¸ºå®‰ï¼Œåˆ‡å‹¿ç›²ç›®åŠ æ æ†ã€‚";
                            }

                            sentiment.value = {
                                today,
                                yesterday,
                                analysis,
                                prediction,
                                advice
                            };
                        } else {
                            throw new Error('Invalid data');
                        }
                    } catch (e) {
                        console.error('Fetch sentiment error', e);
                        // Fallback data
                        const now = new Date();
                        const yest = new Date(now);
                        yest.setDate(yest.getDate() - 1);
                        const formatDate = (d) => `${d.getMonth() + 1}æœˆ${d.getDate()}æ—¥`;

                        sentiment.value = {
                            today: { 
                                value: "50", 
                                value_classification: "Neutral",
                                dateStr: formatDate(now)
                            },
                            yesterday: { 
                                value: "50", 
                                value_classification: "Neutral",
                                dateStr: formatDate(yest)
                            },
                            analysis: ["æ— æ³•è·å–æœ€æ–°å¸‚åœºæƒ…ç»ªæ•°æ®", "è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•"],
                            prediction: ["æ•°æ®æš‚æ—¶ä¸å¯ç”¨", "å»ºè®®å‚è€ƒæŠ€æœ¯æŒ‡æ ‡è¿›è¡Œåˆ¤æ–­"],
                            advice: "æ¥å£è¯·æ±‚å¤±è´¥ï¼Œæš‚æ—¶æ— æ³•æä¾›æ“ä½œå»ºè®®ã€‚"
                        };
                    }
                };

                const getSentimentClass = (val) => {
                    val = parseInt(val);
                    if (val <= 25) return 'fng-extreme-fear';
                    if (val <= 45) return 'fng-fear';
                    if (val <= 55) return 'fng-neutral';
                    if (val <= 75) return 'fng-greed';
                    return 'fng-extreme-greed';
                };

                const getSentimentColor = (val) => {
                    val = parseInt(val);
                    if (val <= 25) return '#3fb950'; // Extreme Fear (Green for buy opportunity)
                    if (val <= 45) return '#a371f7'; // Fear
                    if (val <= 55) return '#d29922'; // Neutral
                    if (val <= 75) return '#f85149'; // Greed
                    return '#da3633'; // Extreme Greed
                };

                const getSentimentEmoji = (classification) => {
                    if (classification.includes('Extreme Fear')) return 'ğŸ˜±';
                    if (classification.includes('Fear')) return 'ğŸ˜¨';
                    if (classification.includes('Neutral')) return 'ğŸ˜';
                    if (classification.includes('Extreme Greed')) return 'ğŸ¤‘';
                    if (classification.includes('Greed')) return 'ğŸ˜ƒ';
                    return '';
                };

                const getSentimentChange = (today, yesterday) => {
                    const diff = parseInt(today) - parseInt(yesterday);
                    if (diff > 0) return `+${diff} (ä¸Šå‡ ğŸ”¼)`;
                    if (diff < 0) return `${diff} (ä¸‹é™ ğŸ”½)`;
                    return `0 (æŒå¹³ â–)`;
                };

                const openChart = (coin) => {
                    activeCoin.value = coin;
                    showModal.value = true;
                    // Reset states
                    timeframes.value.forEach(tf => {
                        tf.loading = true;
                        tf.trend = '';
                        tf.candleCount = 0;
                    });
                    // Wait for modal to render
                    setTimeout(() => {
                        renderCharts(coin);
                    }, 100);
                };

                const closeModal = () => {
                    showModal.value = false;
                    // Cleanup charts
                    Object.keys(chartInstances).forEach(key => {
                        try {
                            if (chartInstances[key]) {
                                chartInstances[key].remove();
                            }
                        } catch(e) {
                            console.warn('Cleanup chart error', e);
                        }
                        delete chartInstances[key];
                    });
                };

                // ==================================================================================
                // ã€å±•ç¤ºå±‚ã€‘å›¾è¡¨æ¸²æŸ“æ§åˆ¶å™¨ (Presentation Controller)
                // ==================================================================================
                // è´Ÿè´£å¼¹çª—å†…çš„ Lightweight Charts å®ä¾‹åŒ–ä¸ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚
                // èŒè´£ï¼š
                // 1. DOM å‡†å¤‡ä¸æ¸…ç†ï¼šç¡®ä¿ Canvas å®¹å™¨å­˜åœ¨ä¸”æ— æ®‹ç•™ã€‚
                // 2. æ•°æ®è·å–ï¼šæŒ‰éœ€åŠ è½½ç‰¹å®šå¸ç§çš„ K çº¿æ•°æ®ã€‚
                // 3. æŒ‡æ ‡è®¡ç®—ï¼šè°ƒç”¨ calculateSupertrendFull ç”Ÿæˆç»˜å›¾æ•°æ®ã€‚
                // 4. ç»˜å›¾è°ƒç”¨ï¼šé…ç½®å›¾è¡¨å‚æ•°ï¼Œæ·»åŠ  Seriesï¼Œå¤„ç† Resizeã€‚
                // ==================================================================================
                const renderCharts = async (coin) => {
                    await Vue.nextTick();
                    await new Promise(r => setTimeout(r, 300));

                    if (typeof LightweightCharts === 'undefined') {
                        console.error('LightweightCharts library not loaded');
                        return;
                    }

                    for (const tf of timeframes.value) {
                        try {
                            const container = document.getElementById(`chart-${tf.bar}`);
                            if (!container) continue;

                            // ç¡®ä¿å®¹å™¨æœ‰å®½åº¦ï¼Œå¦‚æœä¸º0åˆ™å°è¯•è·å–çˆ¶çº§å®½åº¦
                            let width = container.clientWidth;
                            if (!width || width < 100) width = container.parentElement ? container.parentElement.clientWidth - 40 : 800;
                            
                            // å¢åŠ é‡è¯•é€»è¾‘é¿å… 429
                            let ohlc = null;
                            let retries = 3;
                            while(retries > 0) {
                                try {
                                    // å¢åŠ è¯·æ±‚é—´éš”ï¼Œé¿å…è§¦å‘é¢‘ç‡é™åˆ¶
                                    if (timeframes.value.indexOf(tf) > 0) {
                                        await new Promise(r => setTimeout(r, 300));
                                    }
                                    ohlc = await fetchOkxCandles(coin.instId, tf.bar, 300);
                                    if (ohlc) break;
                                } catch (err) {
                                    if (err.message.includes('429')) {
                                        await new Promise(r => setTimeout(r, 1000 + Math.random() * 500));
                                        retries--;
                                        continue;
                                    }
                                    break;
                                }
                                retries--;
                            }

                            if (!ohlc || ohlc.length === 0) {
                                tf.loading = false;
                                tf.trend = 'No Data';
                                container.innerHTML = '<div style="display:flex;justify-content:center;align-items:center;height:100%;color:#8b949e;flex-direction:column;gap:10px;"><span style="font-size:2rem;">ğŸ“‰</span><span>æš‚æ—  K çº¿æ•°æ®</span></div>';
                                continue;
                            }
                            
                            const data = calculateSupertrendFull(ohlc, 10, 3);
                            if (!data) {
                                tf.loading = false;
                                tf.trend = 'Calc Error';
                                container.innerHTML = '<div style="display:flex;justify-content:center;align-items:center;height:100%;color:#f85149;flex-direction:column;gap:10px;"><span style="font-size:2rem;">âš ï¸</span><span>è®¡ç®—æŒ‡æ ‡å‡ºé”™ (æ•°æ®ä¸è¶³)</span></div>';
                                continue;
                            }

                            tf.trend = data.direction;
                            
                            // Basic validation
                            const validCandles = [];
                            const seenTimes = new Set();
                            
                            data.candles.forEach(c => {
                                if (seenTimes.has(c.time)) return;
                                if (c.time && !isNaN(c.open) && !isNaN(c.high) && !isNaN(c.low) && !isNaN(c.close)) {
                                    validCandles.push(c);
                                    seenTimes.add(c.time);
                                }
                            });
                            
                            validCandles.sort((a, b) => a.time - b.time);
                            tf.candleCount = validCandles.length;

                            if (validCandles.length === 0) {
                                tf.loading = false;
                                container.innerHTML = '<div style="display:flex;justify-content:center;align-items:center;height:100%;color:#8b949e;">æ— æœ‰æ•ˆ K çº¿æ•°æ®</div>';
                                continue;
                            }

                            // Clean up existing only when we are ready to render
                            try {
                                if (chartInstances[tf.bar]) {
                                    chartInstances[tf.bar].remove();
                                }
                            } catch(e) {
                                console.warn('Remove existing chart error', e);
                            }
                            delete chartInstances[tf.bar];
                            container.innerHTML = '';

                            const chart = LightweightCharts.createChart(container, {
                                width: width,
                                height: 380,
                                layout: {
                                    background: { type: 'solid', color: '#0d1117' },
                                    textColor: '#8b949e',
                                },
                                grid: {
                                    vertLines: { color: '#21262d' },
                                    horzLines: { color: '#21262d' },
                                },
                                localization: {
                                    locale: 'zh-CN',
                                    timeFormatter: (timestamp) => {
                                        const date = new Date(timestamp * 1000);
                                        const y = date.getUTCFullYear();
                                        const m = date.getUTCMonth() + 1;
                                        const d = date.getUTCDate();
                                        const h = date.getUTCHours();
                                        const min = date.getUTCMinutes();
                                        const pad = (n) => n.toString().padStart(2, '0');
                                        return `${y}å¹´${m}æœˆ${d}æ—¥ ${pad(h)}:${pad(min)}`;
                                    }
                                },
                                timeScale: {
                                    timeVisible: true,
                                    secondsVisible: false,
                                    borderColor: '#30363d',
                                },
                                rightPriceScale: {
                                    borderColor: '#30363d',
                                    scaleMargins: {
                                        top: 0.05,
                                        bottom: 0.25, // Leave space for RSI
                                    },
                                },
                            });

                            // Add custom price scale for RSI
                            chart.priceScale('rsi').applyOptions({
                                scaleMargins: {
                                    top: 0.8, // Position at bottom
                                    bottom: 0,
                                },
                            });

                            // ==================================================================================
                            // ã€æ¶æ„è®¾è®¡ã€‘å›¾è¡¨å›¾å±‚åˆ†å±‚æ¸²æŸ“ (Layered Rendering Architecture)
                            // ==================================================================================
                            // Lightweight Charts æ²¡æœ‰æ˜¾å¼çš„ z-index æ§åˆ¶ï¼Œå›¾å±‚é®æŒ¡å…³ç³»å–å†³äº addSeries çš„é¡ºåºã€‚
                            // ä¸ºäº†å®ç°â€œäº‘å¸¦å¡«å……ä¸é®æŒ¡ K çº¿â€çš„æ•ˆæœï¼Œæˆ‘ä»¬é‡‡ç”¨ä»¥ä¸‹æ·»åŠ é¡ºåºï¼ˆä»åº•åˆ°é¡¶ï¼‰ï¼š
                            // 
                            // 1. Layer 1 (åº•å±‚): cloudSeries (Candlestick)
                            //    - ä½œç”¨ï¼šæ¨¡æ‹Ÿ Supertrend çš„åŒºåŸŸå¡«å……æ•ˆæœã€‚
                            //    - æŠ€æœ¯ï¼šä½¿ç”¨åŠé€æ˜é¢œè‰²ï¼Œåˆ©ç”¨èœ¡çƒ›å›¾å®ä½“æ¥å¡«å…… ST çº¿åˆ° K çº¿ä¹‹é—´çš„ç©ºéš™ã€‚
                            // 
                            // 2. Layer 2 (ä¸­å±‚): candlestickSeries (Candlestick)
                            //    - ä½œç”¨ï¼šå±•ç¤ºæ ¸å¿ƒä»·æ ¼æ•°æ®ï¼ˆOHLCï¼‰ã€‚
                            //    - ä¸ºä»€ä¹ˆåæ·»åŠ ï¼šç¡®ä¿ K çº¿å®ä½“å§‹ç»ˆæµ®åœ¨äº‘å¸¦ä¹‹ä¸Šï¼Œä¿è¯çœ‹ç›˜æ¸…æ™°åº¦ã€‚
                            // 
                            // 3. Layer 3 (é¡¶å±‚): stSeries (Line) - *åç»­æ·»åŠ *
                            //    - ä½œç”¨ï¼šç»˜åˆ¶ Supertrend è¶‹åŠ¿çº¿ã€‚
                            //    - ä¸ºä»€ä¹ˆæœ€åæ·»åŠ ï¼šç¡®ä¿è¶‹åŠ¿çº¿å‹åœ¨æ‰€æœ‰å…ƒç´ ä¹‹ä¸Šï¼Œæä¾›æ˜ç¡®çš„æ”¯æ’‘/å‹åŠ›ä½æŒ‡ç¤ºã€‚
                            // ==================================================================================

                            // Add Cloud Series (Rendered behind candles)
                            // æ·»åŠ äº‘å¸¦å›¾å±‚ï¼ˆæ¸²æŸ“åœ¨ K çº¿å›¾å±‚ä¸‹æ–¹ï¼‰
                            // è¿™æ˜¯ä¸€ä¸ª CandlestickSeriesï¼ˆèœ¡çƒ›å›¾ï¼‰ï¼Œç”¨äºæ¨¡æ‹Ÿâ€œåŒºåŸŸå¡«å……â€æ•ˆæœ
                            const cloudSeries = chart.addCandlestickSeries({
                                upColor: 'rgba(34, 197, 94, 0.15)',   // ä¸Šæ¶¨è¶‹åŠ¿äº‘å¸¦é¢œè‰²ï¼ˆåŠé€æ˜ç»¿ï¼‰
                                downColor: 'rgba(239, 68, 68, 0.15)', // ä¸‹è·Œè¶‹åŠ¿äº‘å¸¦é¢œè‰²ï¼ˆåŠé€æ˜çº¢ï¼‰
                                borderVisible: false,                  // éšè—è¾¹æ¡†ï¼Œä½¿å¡«å……çœ‹èµ·æ¥æ›´æŸ”å’Œ
                                wickVisible: false,                    // éšè—å½±çº¿ï¼Œåªæ˜¾ç¤ºå®ä½“éƒ¨åˆ†ä½œä¸ºå¡«å……åŒº
                                lastValueVisible: false,               // ä¸åœ¨ä»·æ ¼è½´æ˜¾ç¤ºæ•°å€¼æ ‡ç­¾
                                priceLineVisible: false,               // ä¸æ˜¾ç¤ºå½“å‰ä»·æ ¼çº¿
                            });

                            const candlestickSeries = chart.addCandlestickSeries({
                                upColor: '#238636',
                                downColor: '#da3633',
                                borderVisible: false,
                                wickUpColor: '#238636',
                                wickDownColor: '#da3633',
                            });

                            candlestickSeries.setData(validCandles);

                            // Calculate and add RSI
                            const rsiData = calculateRSI(ohlc, 14);
                            if (rsiData.length > 0) {
                                const rsiSeries = chart.addLineSeries({
                                    color: '#7e22ce', // Purple-ish
                                    lineWidth: 2,
                                    priceScaleId: 'rsi',
                                    lastValueVisible: false,
                                    priceLineVisible: false,
                                });
                                rsiSeries.setData(rsiData);
                                
                                // Add RSI Thresholds
                                rsiSeries.createPriceLine({
                                    price: 70,
                                    color: '#f85149',
                                    lineWidth: 1,
                                    lineStyle: LightweightCharts.LineStyle.Dashed,
                                    axisLabelVisible: false,
                                });
                                rsiSeries.createPriceLine({
                                    price: 30,
                                    color: '#3fb950',
                                    lineWidth: 1,
                                    lineStyle: LightweightCharts.LineStyle.Dashed,
                                    axisLabelVisible: false,
                                });
                                rsiSeries.createPriceLine({
                                    price: 50,
                                    color: '#8b949e',
                                    lineWidth: 1,
                                    lineStyle: LightweightCharts.LineStyle.Dotted,
                                    axisLabelVisible: false,
                                });
                            }

                            // ==================================================================================
                            // ã€æ ¸å¿ƒç®—æ³•ã€‘æ•°æ®è½¬æ¢ä¸è§†è§‰å¤„ç†ç®¡çº¿ (Data Transformation Pipeline)
                            // ==================================================================================
                            // æœ¬æ¨¡å—è´Ÿè´£å°†åŸå§‹çš„è®¡ç®—æŒ‡æ ‡æ•°æ®è½¬æ¢ä¸º Lightweight Charts å¯è¯†åˆ«çš„ Series æ•°æ®æ ¼å¼ã€‚
                            // åŒ…å«ä¸‰å¤§æ ¸å¿ƒæŠ€æœ¯å®ç°ï¼š
                            //
                            // 1. ã€é€æ˜æ–­ç‚¹æŠ€æœ¯ (Transparent Breakpoint)ã€‘
                            //    - é—®é¢˜ï¼šLineSeries é»˜è®¤ä¼šå°†ç›¸é‚»æ•°æ®ç‚¹è¿æ¥ã€‚å½“è¶‹åŠ¿åè½¬ï¼ˆçº¢å˜ç»¿ï¼‰æ—¶ï¼Œ
                            //           ä¼šäº§ç”Ÿä¸€æ¡æ¨ªè·¨ä»·æ ¼çš„è¿çº¿ï¼ˆç²˜è¿ï¼‰ï¼Œå¹²æ‰°è§†è§‰ã€‚
                            //    - è§£å†³æ–¹æ¡ˆï¼šåˆ©ç”¨ Lightweight Charts "çº¿æ®µé¢œè‰²ç”±èµ·ç‚¹å†³å®š" çš„æ¸²æŸ“ç‰¹æ€§ã€‚
                            //              åœ¨è¶‹åŠ¿åˆ‡æ¢çš„ç¬é—´ï¼Œå°†â€œå‰ä¸€ä¸ªç‚¹â€é¢œè‰²è®¾ä¸ºé€æ˜ (rgba(0,0,0,0))ã€‚
                            //              è¿™ä½¿å¾—ä¸¤ç‚¹é—´çš„è¿çº¿éšå½¢ï¼Œåˆ¶é€ å‡ºç‰©ç†æ–­å¼€çš„è§†è§‰æ•ˆæœã€‚
                            //
                            // 2. ã€äº‘å¸¦æ¨¡æ‹ŸæŠ€æœ¯ (Cloud Simulation)ã€‘
                            //    - é—®é¢˜ï¼šåº“æœ¬èº«ä¸æ”¯æŒâ€œçº¿åˆ°çº¿â€çš„åŠ¨æ€åŒºåŸŸå¡«å……ã€‚
                            //    - è§£å†³æ–¹æ¡ˆï¼šåˆ©ç”¨ CandlestickSeries çš„å®ä½“éƒ¨åˆ†è¿›è¡Œ Hackã€‚
                            //              æ„é€ ä¼ªé€ çš„ OHLC æ•°æ®ï¼Œå°† Open è®¾ä¸º Supertrend å€¼ï¼ŒClose è®¾ä¸º Kçº¿æå€¼ã€‚
                            //              ä»è€Œç”»å‡ºä¸€ä¸ªçŸ©å½¢å®ä½“ï¼Œå®Œç¾å¡«è¡¥æŒ‡æ ‡ä¸ä»·æ ¼é—´çš„ç©ºéš™ã€‚
                            //
                            // 3. ã€ä¿¡å·çŠ¶æ€æœº (Signal State Machine)ã€‘
                            //    - é€»è¾‘ï¼šç»´æŠ¤ prevTrend çŠ¶æ€å˜é‡ã€‚ä»…åœ¨çŠ¶æ€å‘ç”Ÿå¼‚æˆ–å˜åŒ– (!=) æ—¶è§¦å‘ä¹°å–ä¿¡å·ã€‚
                            // ==================================================================================

                            // å¤„ç† Supertrend çº¿æ•°æ®ï¼šä½¿ç”¨ LineSeries + ä¿®æ”¹å‰ä¸€ç‚¹é¢œè‰²ç­–ç•¥
                            // é€»è¾‘ï¼šLineSeries çš„çº¿æ®µé¢œè‰²é€šå¸¸ç”±â€œèµ·å§‹ç‚¹â€å†³å®šã€‚
                            // è¦éšè—ä» A(ä¸Šä¸ªè¶‹åŠ¿ç»ˆç‚¹) åˆ° B(æ–°è¶‹åŠ¿èµ·ç‚¹) çš„è¿çº¿ï¼Œ
                            // æˆ‘ä»¬éœ€è¦å°† A çš„é¢œè‰²è®¾ä¸ºé€æ˜ã€‚
                            const stData = [];    // å­˜å‚¨ Supertrend çº¿æ¡æ•°æ®
                            const cloudData = []; // å­˜å‚¨äº‘å¸¦å¡«å……æ•°æ®ï¼ˆCandlestick æ ¼å¼ï¼‰
                            const markers = [];   // å­˜å‚¨ä¹°å–ä¿¡å·æ ‡è®°
                            
                            // åˆ›å»ºå®Œæ•´çš„ timeline map ä»¥ä¾¿äºæŸ¥æ‰¾
                            // å°† Supertrend æ•°æ®è½¬æ¢ä¸º Mapï¼Œä»¥ä¾¿é€šè¿‡æ—¶é—´æˆ³å¿«é€Ÿè·å–å¯¹åº”çš„å€¼
                            const stMap = new Map();
                            data.supertrendSeries.forEach(item => {
                                stMap.set(item.time, item);
                            });

                            let prevTrend = null; // è®°å½•ä¸Šä¸€ä¸ªæ—¶é—´ç‚¹çš„è¶‹åŠ¿çŠ¶æ€ (true=æ¶¨/ç»¿, false=è·Œ/çº¢)

                            // éå†æ‰€æœ‰æœ‰æ•ˆ K çº¿æ—¶é—´ç‚¹
                            validCandles.forEach(c => {
                                const item = stMap.get(c.time); // è·å–å½“å‰æ—¶é—´ç‚¹çš„ Supertrend æ•°æ®
                                
                                if (item && !isNaN(item.value)) {
                                    const isUp = item.color === '#22c55e'; // åˆ¤æ–­å½“å‰è¶‹åŠ¿æ–¹å‘
                                    
                                    // å½“å‰ç‚¹çš„é¢œè‰² (ç»¿æˆ–çº¢)
                                    const pointColor = isUp ? '#22c55e' : '#ef4444';
                                    
                                    // å…³é”®é€»è¾‘ï¼šå¦‚æœè¶‹åŠ¿å‘ç”Ÿå˜åŒ–ï¼ˆä»ç»¿å˜çº¢ï¼Œæˆ–ä»çº¢å˜ç»¿ï¼‰
                                    // å°†ã€ä¸Šä¸€ä¸ªç‚¹ã€‘çš„é¢œè‰²è®¾ä¸ºé€æ˜ã€‚
                                    if (prevTrend !== null && prevTrend !== isUp) {
                                        if (stData.length > 0) {
                                            // ä¿®æ”¹æ•°ç»„ä¸­æœ€åä¸€ä¸ªæ•°æ®ç‚¹çš„é¢œè‰²ä¸ºé€æ˜
                                            // æ•ˆæœï¼šéšè—äº†ä»â€œä¸Šä¸€ä¸ªç‚¹â€åˆ°â€œå½“å‰ç‚¹â€çš„è¿çº¿ï¼Œå½¢æˆè§†è§‰æ–­å¼€
                                            stData[stData.length - 1].color = 'rgba(0, 0, 0, 0)';
                                        }
                                    }

                                    // æ¨å…¥å½“å‰ç‚¹çš„çº¿æ¡æ•°æ®
                                    stData.push({
                                        time: c.time,
                                        value: item.value,
                                        color: pointColor // LineSeries v4 æ”¯æŒå•ç‚¹é¢œè‰²
                                    });

                                    // Cloud Data (åŒºåŸŸå¡«å……)
                                    // ä½¿ç”¨ Candlestick æ¨¡æ‹Ÿå¡«å……ï¼šOpen=ST, Close=CandleLimit
                                    // æˆ‘ä»¬åˆ©ç”¨èœ¡çƒ›å›¾çš„â€œå®ä½“éƒ¨åˆ†â€æ¥ä½œä¸ºå¡«å……åŒºåŸŸ
                                    if (isUp) {
                                        // ç»¿äº‘æƒ…å†µï¼ˆä¸Šæ¶¨è¶‹åŠ¿ï¼‰ï¼š
                                        // å¡«å……åŒºåŸŸèŒƒå›´ï¼šä» Supertrend å€¼(ä¸‹ç•Œ) åˆ° Kçº¿æœ€ä½ä»·(ä¸Šç•Œ)
                                        // æ³¨æ„ï¼šä¸ºäº†è§†è§‰æ•ˆæœï¼Œè¿™é‡Œé€‰æ‹©äº†å¡«å……åˆ° Lowï¼Œè¿™ä¼šè®©äº‘å¸¦ç´§è´´ K çº¿åº•éƒ¨
                                        cloudData.push({
                                            time: c.time,
                                            open: item.value, // å®ä½“åº•éƒ¨
                                            high: c.low,      // å½±çº¿æœ€é«˜ï¼ˆè¿™é‡Œè®¾ä¸ºå’Œ close ä¸€æ ·ï¼Œéšè—å½±çº¿ï¼‰
                                            low: item.value,  // å½±çº¿æœ€ä½ï¼ˆè¿™é‡Œè®¾ä¸ºå’Œ open ä¸€æ ·ï¼Œéšè—å½±çº¿ï¼‰
                                            close: c.low      // å®ä½“é¡¶éƒ¨
                                        });
                                    } else {
                                        // çº¢äº‘æƒ…å†µï¼ˆä¸‹è·Œè¶‹åŠ¿ï¼‰ï¼š
                                        // å¡«å……åŒºåŸŸèŒƒå›´ï¼šä» Supertrend å€¼(ä¸Šç•Œ) åˆ° Kçº¿æœ€é«˜ä»·(ä¸‹ç•Œ)
                                        // æ³¨æ„ï¼šå¡«å……åˆ° Highï¼Œè®©äº‘å¸¦ç´§è´´ K çº¿é¡¶éƒ¨
                                        cloudData.push({
                                            time: c.time,
                                            open: item.value, // å®ä½“é¡¶éƒ¨ (å› ä¸ºæ˜¯è·ŒåŠ¿é¢œè‰²ï¼ŒOpen > Close é€»è¾‘å¯èƒ½åç›´è§‰ï¼Œä½†è¿™é‡Œåªçœ‹ä½ç½®)
                                            high: item.value,
                                            low: c.high,
                                            close: c.high     // å®ä½“åº•éƒ¨
                                        });
                                    }

                                    // ä¿¡å·æ ‡è®° (Buy/Sell Arrows)
                                    if (prevTrend !== null && prevTrend !== isUp) {
                                        if (isUp) { // Turn Green -> Buy (è¶‹åŠ¿ç”±çº¢è½¬ç»¿)
                                            markers.push({
                                                time: c.time,
                                                position: 'belowBar', // æ ‡è®°åœ¨ K çº¿ä¸‹æ–¹
                                                color: '#22c55e',
                                                shape: 'arrowUp',
                                                text: 'Buy',
                                                size: 2
                                            });
                                        } else { // Turn Red -> Sell (è¶‹åŠ¿ç”±ç»¿è½¬çº¢)
                                            markers.push({
                                                time: c.time,
                                                position: 'aboveBar', // æ ‡è®°åœ¨ K çº¿ä¸Šæ–¹
                                                color: '#ef4444',
                                                shape: 'arrowDown',
                                                text: 'Sell',
                                                size: 2
                                            });
                                        }
                                    }
                                    prevTrend = isUp; // æ›´æ–°è¶‹åŠ¿çŠ¶æ€ï¼Œä¾›ä¸‹ä¸€æ¬¡å¾ªç¯æ¯”å¯¹
                                } else {
                                    // æ— æ•°æ®æ—¶ï¼Œæ˜¾å¼æ¨å…¥ whitespace ä»¥ä¿æŒæ—¶é—´è½´å¯¹é½
                                    stData.push({ time: c.time });
                                    cloudData.push({ time: c.time });
                                }
                            });

                            // Set Cloud Data (åº”ç”¨äº‘å¸¦æ•°æ®)
                            cloudSeries.setData(cloudData);

                            // æ·»åŠ  Supertrend Series (æ”¹å› LineSeriesï¼Œä½¿ç”¨é€æ˜è‰²æ–­å¼€)
                            if (stData.length > 0) {
                                const stSeries = chart.addLineSeries({
                                    lineWidth: 2,
                                    priceLineVisible: false,
                                    lastValueVisible: false,
                                    crosshairMarkerVisible: false,
                                    // LineSeries ä¸éœ€è¦ topColor/bottomColor
                                });
                                stSeries.setData(stData);
                            }

                            // æ·»åŠ  Markers åˆ° Kçº¿ Series
                            candlestickSeries.setMarkers(markers);

                            // Add Supertrend Legend
                            let lastValue, lastColor, lastLabel;
                            const lastItem = stData[stData.length - 1];

                            if (lastItem && !isNaN(lastItem.value)) {
                                // æ ¹æ® prevTrend åˆ¤æ–­æœ€åçš„è¶‹åŠ¿çŠ¶æ€
                                if (prevTrend === true) {
                                    lastValue = lastItem.value;
                                    lastColor = '#3fb950';
                                    lastLabel = 'Support';
                                } else if (prevTrend === false) {
                                    lastValue = lastItem.value;
                                    lastColor = '#f85149';
                                    lastLabel = 'Resistance';
                                }
                            }

                            if (lastValue) {
                                const formattedPrice = formatPrice(lastValue);
                                const legend = document.createElement('div');
                                legend.className = 'chart-supertrend-legend';
                                legend.style.borderColor = 'rgba(48, 54, 61, 0.5)';
                                legend.innerHTML = `
                                    <div class="st-legend-dot" style="background: ${lastColor}"></div>
                                    <span style="color: ${lastColor}">${lastLabel}: ${formattedPrice}</span>
                                `;
                                container.appendChild(legend);
                            }

                            chartInstances[tf.bar] = chart;

                            const resizeObserver = new ResizeObserver(entries => {
                                if (entries.length === 0 || entries[0].target !== container) return;
                                const newRect = entries[0].contentRect;
                                if (newRect.width === 0 || newRect.height === 0) return;
                                chart.applyOptions({ width: newRect.width });
                            });
                            resizeObserver.observe(container);

                            // Force fit content after a slight delay to ensure rendering
                            setTimeout(() => {
                                chart.timeScale().fitContent();
                            }, 50);

                        } catch (e) {
                            console.error(`Chart render error ${tf.bar}`, e);
                            tf.trend = 'Error';
                        } finally {
                            tf.loading = false;
                        }
                    }
                };

                // ==================================================================================
                // ã€ä¸šåŠ¡é€»è¾‘ã€‘ä¸»æ•°æ®åŠ è½½ä¸è°ƒåº¦ (Main Data Fetching & Scheduling)
                // ==================================================================================
                // æ ¸å¿ƒæµç¨‹ï¼š
                // 1. è·å–æ‰€æœ‰ USDT äº¤æ˜“å¯¹ Tickers -> æ’åºå–å‰ 250 åã€‚
                // 2. åˆå§‹åŒ–/æ›´æ–° coins åˆ—è¡¨åŸºç¡€ä¿¡æ¯ã€‚
                // 3. ç”Ÿæˆ K çº¿è·å–ä»»åŠ¡é˜Ÿåˆ— (250å¸ç§ * 5å‘¨æœŸ = 1250ä¸ªè¯·æ±‚)ã€‚
                // 4. å¯åŠ¨å¹¶å‘å·¥ä½œæ±  (Worker Pool) æ¶ˆè´¹ä»»åŠ¡é˜Ÿåˆ—ã€‚
                // ==================================================================================
                const fetchData = async () => {
                    loading.value = true;
                    try {
                        const tickers = await fetchOkxTickers();
                        const usdtTickers = tickers.filter(t =>
                            typeof t.instId === 'string' && t.instId.endsWith('-USDT')
                        );

                        usdtTickers.sort((a, b) => {
                            const va = Number(a.volCcy24h || 0);
                            const vb = Number(b.volCcy24h || 0);
                            return vb - va;
                        });

                        const top = usdtTickers.slice(0, 250);

                        // Create a map of existing coins to preserve their state
                        const existingCoinsMap = new Map();
                        if (coins.value && coins.value.length > 0) {
                            coins.value.forEach(c => existingCoinsMap.set(c.symbol, c));
                        }

                        const baseCoins = top.map((t, idx) => {
                            const instId = t.instId;
                            const base = instId.split('-')[0];
                            const price = Number(t.last || 0);
                            // sodUtc8 is Open price at UTC+8 (Beijing Time 00:00)
                            const openUtc8 = Number(t.sodUtc8 || t.open24h || price);
                            const changePercent = openUtc8 ? ((price - openUtc8) / openUtc8) * 100 : 0;

                            const existing = existingCoinsMap.get(base);

                            return {
                                rank: idx + 1,
                                name: base,
                                symbol: base,
                                price,
                                changePercent,
                                image: coinIconUrl(base),
                                // Preserve existing trends if available, otherwise 'Loading'
                                trend_15m: existing ? existing.trend_15m : 'Loading',
                                trend_1h: existing ? existing.trend_1h : 'Loading',
                                trend_4h: existing ? existing.trend_4h : 'Loading',
                                trend_1d: existing ? existing.trend_1d : 'Loading',
                                trend_1w: existing ? existing.trend_1w : 'Loading',
                                sparkline: existing ? existing.sparkline : [],
                                instId
                            };
                        });

                        coins.value = baseCoins;
                        lastUpdated.value = new Date().toISOString();

                        const tasks = [];
                        const bars = [
                            { bar: '15m', key: 'trend_15m' },
                            { bar: '1H', key: 'trend_1h' },
                            { bar: '4H', key: 'trend_4h' },
                            { bar: '1D', key: 'trend_1d' },
                            { bar: '1W', key: 'trend_1w' }
                        ];

                        baseCoins.forEach((coin, index) => {
                            bars.forEach(({ bar, key }) => {
                                tasks.push({ index, instId: coin.instId, bar, key });
                            });
                        });

                        // ğŸŸ¢ Architecture Optimization: Fixed Concurrency Worker Pool
                        // Replaces unstable dynamic scheduler with a robust, zero-delay worker system
                        // Optimized for browser limit (HTTP/1.1 ~6 conns, HTTP/2 multiplexing support)
                        
                // ==================================================================================
                // ã€ä¸šåŠ¡é€»è¾‘ã€‘ä¸»å¹¶å‘è¯·æ±‚è°ƒåº¦å™¨ (Concurrency Worker Pool)
                // ==================================================================================
                // OKX API æœ‰ä¸¥æ ¼çš„é¢‘ç‡é™åˆ¶ï¼Œä¸”æˆ‘ä»¬éœ€è¦è¯·æ±‚ 1250+ ä¸ªæ•°æ®ç‚¹ã€‚
                // å®ç°æ–¹æ¡ˆï¼š
                // 1. å›ºå®šå¹¶å‘æ•° (CONCURRENCY = 8)ï¼šå¹³è¡¡è¯·æ±‚é€Ÿåº¦ä¸ç¨³å®šæ€§ã€‚
                // 2. å…¨å±€é™æµæš‚åœ (pausedUntil)ï¼šå½“æ”¶åˆ° 429 (Too Many Requests) æ—¶ï¼Œ
                //    æ‰€æœ‰ Worker ç«‹å³è¿›å…¥ä¼‘çœ çŠ¶æ€ï¼Œ2-3ç§’åè‡ªåŠ¨æ¢å¤ã€‚
                // 3. é‡è¯•æœºåˆ¶ï¼šæ¯ä¸ªè¯·æ±‚å¤±è´¥åä¼šæœ‰ 3 æ¬¡é‡è¯•æœºä¼šã€‚
                // ==================================================================================
                
                const CONCURRENCY = 8; // Stable "Sweet Spot" for max throughput
                        let cursor = 0;
                        let pausedUntil = 0; // Global pause timestamp for rate limiting

                        const worker = async () => {
                            while (cursor < tasks.length) {
                                // Rate Limit Check
                                if (Date.now() < pausedUntil) {
                                    await new Promise(r => setTimeout(r, pausedUntil - Date.now()));
                                }

                                const task = tasks[cursor++];
                                if (!task) break; // Safety check

                                try {
                                    // Fetch logic with immediate execution (No artificial delays)
                                    let ohlc = null;
                                    let retries = 3;
                                    
                                    while (retries > 0) {
                                        try {
                                            ohlc = await fetchOkxCandles(task.instId, task.bar);
                                            break; // Success
                                        } catch (err) {
                                            if (err.message && err.message.includes('429')) {
                                                // Global Pause Signal
                                                console.warn('Rate limit hit, pausing all workers...');
                                                pausedUntil = Date.now() + 2000 + Math.random() * 1000;
                                                await new Promise(r => setTimeout(r, 2000)); // Wait locally too
                                            } else {
                                                await new Promise(r => setTimeout(r, 1000)); // Network error backoff
                                            }
                                            retries--;
                                        }
                                    }

                                    // Data Processing (Optimized)
                                    let trend = 'Error';
                                    if (ohlc && ohlc.length) {
                                        trend = calculateSupertrend(ohlc, 10, 3);
                                        
                                        // Update sparkline logic
                                        let sparklineData = null;
                                        if (task.bar === '15m') sparklineData = ohlc.slice(-96).map(c => c.close);
                                        else if (task.bar === '1H') sparklineData = ohlc.slice(-24).map(c => c.close);

                                        if (sparklineData) {
                                            if (task.bar === '15m' || !coins.value[task.index].sparkline) {
                                                coins.value[task.index].sparkline = sparklineData;
                                            }
                                        } else if (!coins.value[task.index].sparkline && task.bar !== '15m' && task.bar !== '1H') {
                                            coins.value[task.index].sparkline = ohlc.slice(-24).map(c => c.close);
                                        }
                                    } else if (ohlc === null) {
                                        trend = 'N/A';
                                    }
                                    
                                    // Atomic UI Update
                                    coins.value[task.index][task.key] = trend;

                                } catch (e) {
                                    coins.value[task.index][task.key] = 'Error';
                                }
                            }
                        };

                        // Start Fixed Worker Pool
                        return Promise.all(Array(CONCURRENCY).fill(null).map(() => worker()));
                    } catch (e) {
                        console.error('Fetch error', e);
                    } finally {
                        loading.value = false;
                    }
                };

                onMounted(() => {
                    loadSelection();
                    fetchData();
                    fetchSentiment();
                    // ğŸŸ¢ Increased refresh interval to 5 minutes to accommodate larger dataset (250 coins)
                    setInterval(fetchData, 300000);
                });

                return {
                    coins,
                    loading,
                    lastUpdatedFormatted,
                    searchQuery,
                    filteredCoins,
                    fetchData,
                    formatPrice,
                    sortKey,
                    sortOrder,
                    sortBy,
                    filterStatus,
                    setFilter,
                    loadedCount,
                    loadPercent,
                    stats,
                    coinColor,
                    generateMiniChart,
                    scoreInfo,
                    showModal,
                    activeCoin,
                    openChart,
                    closeModal,
                    timeframes,
                    sentiment,
                    getSentimentClass,
                    getSentimentColor,
                    getSentimentEmoji,
                    getSentimentChange,
                    selectedCoins,
                    viewMode,
                    toggleSelection,
                    isSelected,
                    toggleViewMode
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
